---
title: Prosocial Motivation in TBI
  code
author: "Anthony Gabay"
date: "17th December 2019"
updated: "29th December 2019 ~ Niall Bourke"
output: html_document
---

### Clear workspace
```{r}
# ---- setup ----
rm(list= ls()) # clear screen
options(scipen=999) # gets rid of scientific notation

```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

### load required packages and functions
## pacman allows you to load lots of libraries at once
#install.packages("pacman")

require(pacman)
pacman::p_load(tidyverse, readxl, sjstats, effects, lme4, lmerTest, MASS, car, gridExtra, broom, pander, scales, robustlmm, emmeans, Hmisc, psych, kableExtra, ggpubr, cowplot)

### Function to produce reporting stats for rlmer objects - used often below

## Wald confidence interval code adapted from Ben Bolker at 
## https://gist.github.com/kamermanpr/aaa598485b6e990017375359ff5f4533)

## Then z-value and p-value generation added by Anthony Gabay 12/08/19

stats.rlmerMod <- function(object, level = 0.95) {
  
  # Extract beta coefficients
  beta <- fixef(object)
  
  # Extract names of coefficients
  parm <- names(beta)
  
  # Extract standard errors for the coefficients
  se <- sqrt(diag(vcov(object)))
  
  # Set level of confidence interval
  conf.level <- qnorm((1 + level) / 2)
  
  # Calculate z value
  z = beta/se
  
  # Calculate CI and create table
  ctab <- cbind(beta,
                beta - (conf.level * se), 
                beta + (conf.level * se),
                se,
                z,
                2*pnorm(-abs(z)))
  
  
  # label column names
  colnames(ctab) <- c('beta',
                      paste(100 * ((1 - level) / 2), '%'),
                      paste(100 * ((1 + level) / 2), '%'),
                      'SE',
                      'z',
                      'p')
  
 
  # Output
  return(round(ctab[parm, ],3))
  
  
}

```


## Reformating Cognitrack date
```{r}
# 
# tmp1 <- strsplit(tmpS," ")[[1]] # 
# xx <- paste(tmp1[2:4], sep = " ", collapse = "")
# xy <- as.Date(xx, format = "%B %d %Y")

```


This script will run the analyses in the same way as we have done for Pat's recent paper. It should be decently commented so you can see what's going on.

```{r, Formating options}

if (!require("RColorBrewer")) {
install.packages("RColorBrewer")
library(RColorBrewer)
}

library("ggsci")

## Formating options ##
# show_col(pal_npg("nrc")(10))
myPalette <- c("#3399FF","#FF0000")
fillPalette <- (scale_fill_npg()) # (scale_fill_rickandmorty())
colPalette <- (scale_color_npg()) # (scale_color_rickandmorty())
npgGroupPalette <- c("#4DBBD5FF","#E64B35FF")
npgAgentPalette <- c("#00A087FF","#3C5488FF")

# Other colour options
# scale_color_tron() # Good with dark theme

# The errorbars overlapped, so use position_dodge to move them horizontally
pd <- position_dodge(0.1) # move them .05 to the left and right 
ebSize <- 1
pointSize <- 4

# Font type & size
textOption <- element_text(family="Times", size = 22)

```

###  Load in dataframes for effort task 

I've kept this section in so that I have access to all the brain data and k-values etc. However, the data for the mixed models is now from a different excel file in order to have all trial information rather than proportion chosen etc. I'll share that file with you.

Niall, you'll need to change the file paths back to yours.

```{r, include=FALSE}

# Set user 
user=2 # 1
# 1: Anthony
# x: Niall 

# Load data depending on user paths
 if (user==1) {

   #### Load in full SOC neuropsych dataframe ####
  soc.df <- read_xlsx("C:\\Users\\antho\\OneDrive\\Niall\\effortData.xlsx", 
                            sheet = "data",
                            col_names = TRUE)

  # Only exclude under calibrated
  qSoc.df <- soc.df[ which(soc.df$ID!='SOC002' & soc.df$ID!='SOC005' & soc.df$ID!='SOC026' & soc.df$ID!='SOC037'), ]

  #### Full effort results in long format ####
  effortLong <- read_xlsx("C:\\Users\\antho\\OneDrive\\Niall\\effortData.xlsx", 
                            sheet = "effortLong",
                            col_names = TRUE)

  qEffortLong <- effortLong[ which(effortLong$ID!='2' & effortLong$ID!='5' & effortLong$ID!='26' & effortLong$ID!='37'), ]


  ## Patient only data with old imaging
  dat <- read_xlsx("C:\\Users\\antho\\OneDrive\\Niall\\effortData.xlsx", 
                            sheet = "patients",
                            col_names = TRUE)
  
  qDat <- dat[ which(dat$ID!='SOC002' & dat$ID!='SOC005' & dat$ID!='SOC026' & dat$ID!='SOC037'), ]

   
 } else {
  #### Load in full SOC neuropsych dataframe ####
  soc.df <- read_xlsx("~/Google Drive/Imperial/PhD/Thesis/analysis/effort/df/effortData.xlsx", 
                            sheet = "data",
                            col_names = TRUE)

  # Only exclude under calibrated
  qSoc.df <- soc.df[ which(soc.df$ID!='SOC002' & soc.df$ID!='SOC005' & soc.df$ID!='SOC026' & soc.df$ID!='SOC037'), ]

  #### Full effort results in long format ####
  effortLong <- read_xlsx("~/Google Drive/Imperial/PhD/Thesis/analysis/effort/df/effortData.xlsx", 
                            sheet = "effortLong",
                            col_names = TRUE)

  qEffortLong <- effortLong[ which(effortLong$ID!='2' & effortLong$ID!='5' & effortLong$ID!='26' & effortLong$ID!='37'), ]


  ## Patient only data with old imaging
  dat <- read_xlsx("~/Google Drive/Imperial/PhD/Thesis/analysis/effort/df/effortData.xlsx", 
                            sheet = "patients",
                            col_names = TRUE)
  
  qDat <- dat[ which(dat$ID!='SOC002' & dat$ID!='SOC005' & dat$ID!='SOC026' & dat$ID!='SOC037'), ]

 }


```


## Choice data GLMM

### Tidy the data

Niall, I'll share the excel file with the data. 

```{r}

 if (user==1) {
    ### Load the data
    data.pMyO = read_xlsx(
    "C:\\Users\\antho\\OneDrive\\Niall\\Niall_data.xlsx", 
    col_names = T)
   
 } else {
   ### Load the data
   data.pMyO = read_xlsx( "~/Google Drive/Imperial/antShare/Niall_data.xlsx", 
      col_names = T)
 }


# Tidy the data
data.choice <- 
  data.pMyO                         %>%  # renames variable
  filter(Choice < 2)                %>%  # removes missing data ( if its 2 it was a missed trial: remove)
  mutate(ID = factor(ID))           %>%  # recodes as factor
  mutate(Choice = factor(Choice))   %>%  # recodes as factor
  mutate(Reward = factor(Reward))   %>%  # recodes as factor
  mutate(Effort = factor(Effort))   %>%  # recodes as factor
  mutate(Agent = factor(Agent))     %>%  # recodes as factor
  mutate(Success = factor(Success)) %>%  # recodes as factor
  mutate(Group = factor(Group))     %>%    # recodes as factor
  dplyr::filter(!ID %in% c('SOC002', 'SOC005', 'SOC026', 'SOC037')) # remove undercalibrated

```


### Run the model

```{r}

### This is a generalized linear mixed model (glmm) on the choice data.

# No need to run this model (it takes time), because the line below will load the model object from the shared folder. If you do want to run it, just uncomment below

 # model.choice <- glmer(Choice ~ Group*Agent*Effort*Reward + (1|ID),
 #                      data = data.choice, family = 'binomial',
 #               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

#saveRDS(model.choice, "C:\\Users\\antho\\OneDrive\\Niall\\model.choice.RDS")



 if (user==1) {
   
  model.choice <- readRDS("C:\\Users\\antho\\OneDrive\\Niall\\model.choice.RDS")
 
  } else {
    
  model.choice <- readRDS("~/Google Drive/Imperial/antShare/model.choice.RDS")

 }

Anova(model.choice, type = 2)

```


### Visualise the results

I'll visualise this with bar charts because it's easier to see the effects, but you may want to do boxplots for a publication if they want to see datapoints.

You'll want to look at the final plot in a pop-out window to see it properly.

I have kept the default colours because I can't be bothered to make them prettier :)

#### Main effects
```{r}

#### Plot the choice data - barcharts

# I've commented first plot definition to explain what the tidyverse code is doing

### Main effects

## Group

plt.group <- 
  data.choice                                   %>%     # take dataset
  mutate(Choice = as.numeric(Choice)-1)         %>%     # make choice numeric
  group_by(ID, Group)                           %>%     # group by
  dplyr::summarise(mean_choice = mean(Choice))  %>%     # find mean for each level of groups
  
  #*nb# Choice here mean of more effortful?
    
  # define plot
  ggplot(., aes(x = Group, y = mean_choice, fill = Group)) +
  geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
  geom_errorbar(stat = "summary",  
                width = 0.2, position=position_dodge(0.9)) +
  ylab("Proportion chosen") +
  xlab("Group") +
  scale_x_discrete(labels = c("Controls", "Patients")) +
  theme(legend.position = "none") +
  ylim(0,1) +
  ggtitle("Main effect of Group") +
  scale_fill_manual(values=npgGroupPalette) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))

## Agent

plt.agent <- 
  data.choice                                   %>%     # take dataset
  mutate(Choice = as.numeric(Choice)-1)         %>%     # make choice numeric
  group_by(ID, Agent)                           %>%     # group by
  dplyr::summarise(mean_choice = mean(Choice))  %>%     # find mean for each level of groups
  
  # define plot
  ggplot(., aes(x = Agent, y = mean_choice, fill = Agent)) +
  geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
  geom_errorbar(stat = "summary",  
                width = 0.2, position=position_dodge(0.9)) +
  ylab("Proportion chosen") +
  xlab("Group") +
  scale_x_discrete(labels = c("Self", "Other")) +  #*nb# Label should be self/other rather than contol/patient? # "Controls", "Patients"
  theme(legend.position = "none") +
  ylim(0,1) +
  ggtitle("Main effect of Agent") +
  scale_fill_manual(values=npgAgentPalette) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))



## Effort

plt.effort <- 
  data.choice                                   %>%     # take dataset
  mutate(Choice = as.numeric(Choice)-1)         %>%     # make choice numeric
  group_by(ID, Effort)                           %>%     # group by
  dplyr::summarise(mean_choice = mean(Choice))  %>%     # find mean for each level of groups
  
  # define plot
  ggplot(., aes(x = Effort, y = mean_choice, fill = Effort)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary",width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    theme(legend.position = "none") +
    ylim(0,1) +
    ggtitle("Main effect of Effort") +
    scale_fill_brewer(palette = "Oranges") + #fillPalette
    theme(text = textOption, plot.title = element_text(hjust = 0.5))

## Reward

plt.reward <- 
  data.choice                                   %>%     # take dataset
  mutate(Choice = as.numeric(Choice)-1)         %>%     # make choice numeric
  group_by(ID, Reward)                           %>%     # group by
  dplyr::summarise(mean_choice = mean(Choice))  %>%     # find mean for each level of groups
  
  # define plot
  ggplot(., aes(x = Reward, y = mean_choice, fill = Reward)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary",  width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Reward level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    theme(legend.position = "none") +
    #theme_dark() +
    ylim(0,1) +
    ggtitle("Main effect of Reward") + 
    scale_fill_brewer(palette = "BuPu") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


### Put it all together

mainEffects <- ggarrange(plt.group, 
                plt.agent, 
                plt.effort,
                plt.reward,
                nrow = 2, ncol = 2)

ggdraw(mainEffects)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/mainEffects.pdf", plot = mainEffects, width = 12, height = 8, units = c("in"), dpi = 300)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/mainEffects.png", plot = mainEffects, width = 12, height = 8, units = c("in"), dpi = 300)


```


#### 2-way interactions
```{r}

### 2-way interaction visualisations

## Group*Agent

plt.group.agent <- 
  data.choice                                   %>%     # take dataset
  mutate(Choice = as.numeric(Choice)-1)         %>%     # make choice numeric
  group_by(ID, Group, Agent)                    %>%     # group by
  dplyr::summarise(mean_choice = mean(Choice))  %>%     # find mean for each level of groups
  
  # define plot
  ggplot(., aes(x = Group, y = mean_choice, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Group") +
    scale_x_discrete(labels = c("Controls", "Patients")) +
    ylim(0,1) +
    ggtitle("Group & Agent") + 
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))



## Group*Effort

plt.group.effort <- 
  data.choice                                   %>%
  mutate(Choice = as.numeric(Choice)-1)         %>%
  group_by(ID, Group, Effort)                   %>%
  dplyr::summarise(mean_choice = mean(Choice))  %>%
  ggplot(., aes(x = Effort, y = mean_choice, fill = Group)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgGroupPalette, labels = c("Controls", "Patients")) + #scale_fill_discrete(labels = c("Controls", "Patients")) +
    ylim(0,1) +
    ggtitle("Group & Effort") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


## Agent*Reward 

plt.agent.reward <- 
  data.choice                                   %>%
  mutate(Choice = as.numeric(Choice)-1)         %>%
  group_by(ID, Agent, Reward)                   %>%
  dplyr::summarise(mean_choice = mean(Choice))  %>%
  ggplot(., aes(x = Reward, y = mean_choice, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Reward level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_discrete(labels = c("Self", "Other")) +
    ylim(0,1) +
    ggtitle("Agent & Reward") +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))

## Group*Reward

plt.group.reward <- 
  data.choice                                   %>%
  mutate(Choice = as.numeric(Choice)-1)         %>%
  group_by(ID, Group, Reward)                   %>%
  dplyr::summarise(mean_choice = mean(Choice))  %>%
  ggplot(., aes(x = Reward, y = mean_choice, fill = Group)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Reward level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgGroupPalette, labels = c("Controls", "Patients")) + #scale_fill_discrete(labels = c("Controls", "Patients")) +
    ylim(0,1) +
    ggtitle("Group & Reward") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))

### Put it all together

twoWayInteractions <- ggarrange(plt.group.agent, 
                        plt.group.effort,
                        plt.agent.reward,
                        plt.group.reward,
                        nrow = 2, ncol = 2)

ggdraw(twoWayInteractions)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/twoWayInteractions.pdf", plot = twoWayInteractions, width = 12, height = 8, units = c("in"), dpi = 300)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/twoWayInteractions.png", plot = twoWayInteractions, width = 12, height = 8, units = c("in"), dpi = 300)

```


#### 3-way interaction
```{r}


### 3-way interaction visualisation (Agent*Effort*Reward)

# Will plot agent by effort, for each level of reward

plt.agent.effort1 <- 
  data.choice                                   %>%
  mutate(Choice = as.numeric(Choice)-1)         %>%
  dplyr::filter(Reward == 2)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_choice = mean(Choice))  %>%
  ggplot(., aes(x = Effort, y = mean_choice, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge(), alpha = 0.80) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + #scale_fill_discrete(labels = c("Self", "Other")) +
    ylim(0,1) +
    ggtitle("Reward level 1") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))

plt.agent.effort2 <- 
  data.choice                                   %>%
  mutate(Choice = as.numeric(Choice)-1)         %>%
  dplyr::filter(Reward == 3)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_choice = mean(Choice))  %>%
  ggplot(., aes(x = Effort, y = mean_choice, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge(), alpha = 0.85) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + #scale_fill_discrete(labels = c("Self", "Other")) +
    ylim(0,1) +
    ggtitle("Reward level 2") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))

plt.agent.effort3 <- 
  data.choice                                   %>%
  mutate(Choice = as.numeric(Choice)-1)         %>%
  dplyr::filter(Reward == 4)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_choice = mean(Choice))  %>%
  ggplot(., aes(x = Effort, y = mean_choice, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge(), alpha = 0.90) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + #scale_fill_discrete(labels = c("Self", "Other")) +
    ylim(0,1) +
    ggtitle("Reward level 3") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))

plt.agent.effort4 <- 
  data.choice                                   %>%
  mutate(Choice = as.numeric(Choice)-1)         %>%
  dplyr::filter(Reward == 5)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_choice = mean(Choice))  %>%
  ggplot(., aes(x = Effort, y = mean_choice, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge(), alpha = 0.95) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + 
    ylim(0,1) +
    ggtitle("Reward level 4") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))

plt.agent.effort5 <- 
  data.choice                                   %>%
  mutate(Choice = as.numeric(Choice)-1)         %>%
  dplyr::filter(Reward == 6)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_choice = mean(Choice))  %>%
  ggplot(., aes(x = Effort, y = mean_choice, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary",  width = 0.2, position=position_dodge(0.9)) +
    ylab("Proportion chosen") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + #scale_fill_discrete(labels = c("Self", "Other")) +
    ylim(0,1) +
    ggtitle("Reward level 5") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


rewardLevel <- ggarrange(plt.agent.effort1, 
                plt.agent.effort2, 
                plt.agent.effort3,
                plt.agent.effort4,
                plt.agent.effort5,
                nrow = 3, ncol = 2, common.legend = TRUE,
                             legend = "right")

ggdraw(rewardLevel)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/rewardLevel.pdf", plot = rewardLevel, width = 12, height = 8, units = c("in"), dpi = 300)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/rewardLevel.png", plot = rewardLevel, width = 12, height = 8, units = c("in"), dpi = 300)



```

#### Post-hoc comparisons of choice data
```{r}

#### post-hoc tests on the choice model

### 3-way interaction
## extracts marginal effects for the 3-way interaction and then contrasts by Reward level
# in other words, it tests the agent*effort interaction at each level of reward

emms.3way <- emmeans(model.choice, ~ Agent*Effort*Reward, type = "unlink") # since this is a glmm, the effect size is an odds ratio.                                                         Unlink turns the estimate (which is in the log(odds) scale) back into an OR

con.3way <- as.data.frame(contrast(emms.3way, interaction = c( "poly"), by = "Reward"))  %>%
  dplyr::filter(Effort_poly == "linear")          %>%  # "interaction = poly" tests linear, quadratic etc contrasts. Since we're only interested in the linear, this line selects just the linear contrasts
  
  dplyr::select(-Agent_poly, -Effort_poly)        %>%  # drops 2 columns which aren't needed
  mutate(Reward = as.numeric(Reward))                  # sents reward levels 1-5 instead of 2-6           

# makes a pretty table
kable(round(con.3way, 3), 
      caption = "Post-hoc comparisons: testing the Agent*Effort interaction at each level of Reward") %>% 
  footnote("p-values uncorrected") %>%
  kable_styling()


### 2-way interaction: Group*Agent
emms.groupAgent <- emmeans(model.choice, ~ Group*Agent, type = "unlink")

con.groupAgent <- as.data.frame(contrast(
  emms.groupAgent, interaction = c( "poly"), by = "Agent")
  )                                               %>%
  dplyr::select(-Group_poly)                      %>% 
  mutate(Agent = as.numeric(Agent))               %>% # doing this so i can round to 3dp below
  round(.,3)                                      %>% # round to 3 decimal places
  mutate(Agent = case_when(Agent == 1 ~ "Self",
                           Agent == 2 ~ "Other"))        # replaces 1&2s with self&other

# makes a pretty table
kable(con.groupAgent, 
      caption = "Post-hoc comparisons: testing the Group effect at each level of Agent") %>% 
  footnote("p-values uncorrected") %>%
  kable_styling()


### Second 2-way interaction: Group*Agent

emms.groupAgent2 <- emmeans(model.choice, ~ Group*Agent, type = "unlink")

con.groupAgent2 <- as.data.frame(contrast(
  emms.groupAgent2, interaction = c( "poly"), by = "Group")
  )                                               %>%
  dplyr::select(-Agent_poly)                      %>% 
  mutate(Group = as.numeric(Group))               %>% # doing this so i can round to 3dp below
  round(.,3)                                      %>% # round to 3 decimal places
  mutate(Group = case_when(Group == 1 ~ "Patient",
                           Group == 2 ~ "Control"))        # replaces 1&2s with self&other

# makes a pretty table
kable(con.groupAgent2, 
      caption = "Post-hoc comparisons: testing the Agent effect at each level of Group") %>% 
  footnote("p-values uncorrected") %>%
  kable_styling()




### 2-way interaction: Group*Effort

emms.groupEffort <- emmeans(model.choice, ~ Group*Effort, type = "unlink")

con.groupEffort <- as.data.frame(contrast(emms.groupEffort, interaction = c( "poly"), by = "Effort", adjust="Bonferroni")) %>%
  dplyr::select(-Group_poly)                      %>% 
  mutate(Effort = as.numeric(Effort))             %>%  
  round(.,3)                                    # round to 3 decimal places

# makes a pretty table
kable(con.groupEffort, 
      caption = "Post-hoc comparisons: testing the Group effect at each level of Effort") %>%
      footnote(c("p-values uncorrected")) %>% # "Different strength of effects driving the interaction?"
kable_styling()


# This creates contrasts to explore the interaction
ge <- contrast(emms.groupEffort, list(con.vs.pat2 = c(1,-1,0,0,0,0,0,0,0,0),
                           con.vs.pat3 = c(0,0,1,-1,0,0,0,0,0,0),
                           con.vs.pat4 = c(0,0,0,0,1,-1,0,0,0,0),
                           con.vs.pat5 = c(0,0,0,0,0,0,1,-1,0,0),
                           con.vs.pat6 = c(0,0,0,0,0,0,0,0,1,-1)), 
         adjust = "Bonferroni")   # each contrast is significant except the first
ge

## small function to extract odds ratio and CIs after running emmeans.
# extract effect size (Odds Ratio) of the comparisons and their 95% CI
OR <- function(contrast_obj){
  
  contrast_obj <- as.data.frame(contrast_obj) %>%
    mutate(OR = exp(estimate))                %>%
    mutate(LL = exp(estimate-1.96*SE))        %>%
    mutate(UL = exp(estimate+1.96*SE))
  
}

#ge <- OR(ge)





### 2-way interaction: Group*Reward

emms.groupReward <- emmeans(model.choice, ~ Group*Reward, type = "unlink")

con.groupReward <- as.data.frame(contrast(
  emms.groupReward, interaction = c( "poly"), by = "Reward")
  )                                               %>%
  dplyr::select(-Group_poly)                      %>% 
  mutate(Reward = as.numeric(Reward))             %>%  
  round(.,3)                                      # round to 3 decimal places

# makes a pretty table
kable(con.groupReward, 
      caption = "Post-hoc comparisons: testing the Group effect at each level of Reward") %>% 
  footnote(c("p-values uncorrected", 
             "Different strength of effects driving the interaction?")) %>%
  kable_styling()


### 2-way interaction: Agent*Reward

emms.agentReward <- emmeans(model.choice, ~ Agent*Reward, type = "unlink")

con.agentReward <- as.data.frame(contrast(
  emms.agentReward, interaction = c( "poly"), by = "Reward")
  )                                               %>%
  dplyr::select(-Agent_poly)                      %>% 
  mutate(Reward = as.numeric(Reward))             %>%  
  round(.,3)                                      # round to 3 decimal places

# makes a pretty table
kable(con.agentReward, 
      caption = "Post-hoc comparisons: testing the Agent effect at each level of Reward") %>% 
  footnote(c("p-values uncorrected", 
             "Different strength of effects driving the interaction?")) %>%
  kable_styling()

```



## Force data LMM

### Tidy the data

```{r}
# Tidy data

data.force <- 
  data.choice                         %>%  # renames variable
  dplyr::filter(Success == 1)           # removes unsuccesful data

```


### Run the model



```{r}
### This is a linear mixed model (glmm) on the force data.

# No need to run this model (it takes time), because the line below will load the model object from the shared folder. If you do want to run it, just uncomment below

## linear regressions on force with 4 way - random effect of subject only
# model.force <- lmer(Force_norm ~ Group*Effort*Reward*Agent + (1 | ID), 
#                    data = data.force) 

#saveRDS(model.force, "C:\\Users\\antho\\OneDrive\\Niall\\model.force.RDS")

 if (user==1) {
   
  model.force <- readRDS("C:\\Users\\antho\\OneDrive\\Niall\\model.force.RDS")
 
  } else {
    
  model.force <- readRDS("~/Google Drive/Imperial/antShare/model.force.RDS")

 }

Anova(model.force, type = 2)

```



### Visualise the force results

#### Main effects


```{r}

#### Plot the force data - barcharts


### Main effects

## Group

fplt.group <- 
  data.force                                    %>%     
  group_by(ID, Group)                           %>%     
  dplyr::summarise(mean_force = mean(Force_norm))  %>%     
  
  # define plot
  ggplot(., aes(x = Group, y = mean_force, fill = Group)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Group") +
    scale_x_discrete(labels = c("Controls", "Patients")) +
    ylim(0,1) +
    ggtitle("Main effect of Group") +
    scale_fill_manual(values=npgGroupPalette) +
    theme(text = textOption, plot.title = element_text(hjust = 0.5), legend.position = "none")


## Agent

fplt.agent <- 
  data.force                                    %>%     
  group_by(ID, Agent)                           %>%     
  dplyr::summarise(mean_force = mean(Force_norm))  %>%     
  
  # define plot
  ggplot(., aes(x = Agent, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary",  width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Group") +
    scale_x_discrete(labels = c("Self", "Oher")) + #*nb# Should be self/other?
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
    ylim(0,1) +
    ggtitle("Main effect of Agent") + #*nb# Effect of Agent not Group?
    theme(text = textOption, plot.title = element_text(hjust = 0.5), legend.position = "none")


## Effort

fplt.effort <- 
  data.force                                        %>%     # take dataset
  group_by(ID, Effort)                              %>%     # group by
  dplyr::summarise(mean_force = mean(Force_norm))   %>%     # find mean for each level of groups
  
  # define plot
  ggplot(., aes(x = Effort, y = mean_force, fill = Effort)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_brewer(palette = "Oranges") + #fillPalette
    ylim(0,1) +
    ggtitle("Main effect of Effort") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5), legend.position = "none")



## Reward

fplt.reward <- 
  data.force                                        %>%     # take dataset
  group_by(ID, Reward)                              %>%     # group by
  dplyr::summarise(mean_force = mean(Force_norm))   %>%     # find mean for each level of groups
  
  # define plot
  ggplot(., aes(x = Reward, y = mean_force, fill = Reward)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Reward level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_brewer(palette = "BuPu") + #fillPalette
    ylim(0,1) +
    ggtitle("Main effect of Reward") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5), legend.position = "none")

### Put it all together

forceMain <- ggarrange(fplt.group, 
              fplt.agent, 
              fplt.effort,
              fplt.reward,
              nrow = 2, ncol = 2)

ggdraw(forceMain)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceMain.pdf", plot = forceMain, width = 12, height = 8, units = c("in"), dpi = 300)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceMain.png", plot = forceMain, width = 12, height = 8, units = c("in"), dpi = 300)


```


#### 2-way interactions

```{r}

### 2-way interaction visualisations

## Group*Agent

fplt.group.agent <- 
  data.force                                        %>%     
  group_by(ID, Group, Agent)                        %>%     
  dplyr::summarise(mean_force = mean(Force_norm))   %>%     
  
  # define plot
  ggplot(., aes(x = Group, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Group") +
    scale_x_discrete(labels = c("Controls", "Patients")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + #scale_fill_discrete(labels = c("Self", "Other")) +
    ylim(0,1) +
    ggtitle("Group & Agent") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))




## Group*Effort

fplt.group.effort <- 
  data.force                                        %>%
  group_by(ID, Group, Effort)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
  ggplot(., aes(x = Effort, y = mean_force, fill = Group)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    ylim(0,1) +
    ggtitle("Group & Effort") +
    scale_fill_manual(values=npgGroupPalette, labels = c("Controls", "Patients")) +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


## Group*Reward 

fplt.group.reward <- 
  data.force                                        %>%
  group_by(ID, Group, Reward)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
  ggplot(., aes(x = Reward, y = mean_force, fill = Group)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Reward level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgGroupPalette, labels = c("Controls", "Patients")) + #scale_fill_discrete(labels = c("Controls", "Patients")) +
    ylim(0,1) +
    ggtitle("Group & Reward") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


## Agent*Effort 

fplt.agent.effort <- 
  data.force                                        %>%
  group_by(ID, Agent, Effort)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
  ggplot(., aes(x = Effort, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + # scale_fill_discrete(labels = c("Self", "Other")) +
    ylim(0,1) +
    ggtitle("Agent & Effort") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


## Agent*Reward 

fplt.agent.reward <- 
  data.force                                        %>%
  group_by(ID, Agent, Reward)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
  ggplot(., aes(x = Reward, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised Force") +
    xlab("Reward level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + #scale_fill_discrete(labels = c("Self", "Other")) +
    ylim(0,1) +
    ggtitle("Agent & Reward") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))



### Put it all together

forceChoice <- ggarrange(fplt.group.agent, 
                  fplt.group.effort,
                  fplt.group.reward,
                  fplt.agent.effort,
                  fplt.agent.reward,
                  nrow = 3, ncol = 2)

ggdraw(forceChoice)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceChoice.pdf", plot = forceChoice, width = 12, height = 8, units = c("in"), dpi = 300)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceChoice.png", plot = forceChoice, width = 12, height = 8, units = c("in"), dpi = 300)



```


#### 3-way interactions

**Agent*Effort*Reward**

```{r}


### 3-way interaction visualisation (Agent*Effort*Reward)

# Will plot agent by effort, for each level of reward

fplt.agent.effort1 <- 
  data.force                                    %>%
  dplyr::filter(Reward == 2)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_force = mean(Force_norm))  %>%
  ggplot(., aes(x = Effort, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) +    
    ylim(0,1) +
    ggtitle("Reward level 1") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


fplt.agent.effort2 <- 
  data.force                                    %>%
  dplyr::filter(Reward == 3)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_force = mean(Force_norm))  %>%
  ggplot(., aes(x = Effort, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + 
    ylim(0,1) +
    ggtitle("Reward level 2") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


fplt.agent.effort3 <- 
  data.force                                    %>%
  dplyr::filter(Reward == 4)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_force = mean(Force_norm))  %>%
  ggplot(., aes(x = Effort, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + 
    ylim(0,1) +
    ggtitle("Reward level 3") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


fplt.agent.effort4 <- 
  data.force                                    %>%
  dplyr::filter(Reward == 5)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_force = mean(Force_norm))  %>%
  ggplot(., aes(x = Effort, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + 
    ylim(0,1) +
    ggtitle("Reward level 4") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


fplt.agent.effort5 <- 
  data.force                                    %>%
  dplyr::filter(Reward == 6)                    %>%
  group_by(ID, Agent, Effort)                   %>%
  dplyr::summarise(mean_force = mean(Force_norm))  %>%
  ggplot(., aes(x = Effort, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary",width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + 
    ylim(0,1) +
    ggtitle("Reward level 5") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))



forceRewardLevel <- ggarrange(fplt.agent.effort1, 
                fplt.agent.effort2, 
                fplt.agent.effort3,
                fplt.agent.effort4,
                fplt.agent.effort5,
                nrow = 3, ncol = 2, 
                common.legend = TRUE, legend = "right")

ggdraw(forceRewardLevel)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceRewardLevel.pdf", plot = forceRewardLevel, width = 12, height = 8, units = c("in"), dpi = 300)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceRewardLevel.png", plot = forceRewardLevel, width = 12, height = 8, units = c("in"), dpi = 300)

```


**Agent*Efffort*Group**


```{r}

### 3-way interaction visualisation (Agent*Effort*Group)

# Will plot agent by effort, for each level of Group

# Group controls
fplt.agent.effort1 <- 
  data.force                                        %>%
  dplyr::filter(Group == 1)                         %>%
  group_by(ID, Agent, Effort)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
  ggplot(., aes(x = Effort, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + 
    ylim(0,1) +
    ggtitle("Agent & Effort: Controls") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))

fplt.agent.effort2 <- 
  data.force                                        %>%
  dplyr::filter(Group == 2)                         %>%
  group_by(ID, Agent, Effort)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
  ggplot(., aes(x = Effort, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Effort level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + 
    ylim(0,1) +
    ggtitle("Agent & Effort: Patients") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))

forceEffort <- ggarrange(fplt.agent.effort1, 
                fplt.agent.effort2,
                nrow = 1, ncol = 2, 
                common.legend = TRUE, legend = "right")

ggdraw(forceEffort)

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceEffort.pdf", plot = forceEffort, width = 12, height = 8, units = c("in"), dpi = 300)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceEffort.png", plot = forceEffort, width = 12, height = 8, units = c("in"), dpi = 300)


```

# Alternative plot
```{r}

fplt.agent.effort1 <- 
  data.force                                        %>%
  dplyr::filter(Group == 1)                         %>%
  group_by(ID, Agent, Effort)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
    ggplot(., aes(x = Effort, y = mean_force, color = Agent)) + 
        geom_errorbar(stat = "summary", width = 0.2, position=pd) +
        geom_line(stat =  "summary", fun.y = "mean", size = pointSize) +
        geom_point(stat =  "summary", fun.y = "mean", size = pointSize, position=pd) +
        scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
        scale_color_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
        ggtitle("Agent & Effort: Controls") +
        ylim(0.25, 0.7) +
        theme(text = textOption, plot.title = element_text(hjust = 0.5))

fplt.agent.effort2 <- 
  data.force                                        %>%
  dplyr::filter(Group == 2)                         %>%
  group_by(ID, Agent, Effort)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
    ggplot(., aes(x = Effort, y = mean_force, color = Agent)) + 
        geom_errorbar(stat = "summary", width = 0.2, position=pd) +
        geom_line(stat =  "summary", fun.y = "mean", size = pointSize) +
        geom_point(stat =  "summary", fun.y = "mean", size = pointSize, position=pd) +
        scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
        scale_color_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
        ggtitle("Agent & Effort: Patients") +
        ylim(0.25, 0.7) +
        theme(text = textOption, plot.title = element_text(hjust = 0.5))

forceEffort <- ggarrange(fplt.agent.effort1, 
                fplt.agent.effort2,
                nrow = 1, ncol = 2, 
                common.legend = TRUE, legend = "right")

ggdraw(forceEffort)

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceEffort.pdf", plot = forceEffort, width = 12, height = 8, units = c("in"), dpi = 300)

```


**Agent*Reward*Group**


```{r}

### 3-way interaction visualisation (Agent*Reward*Group)

# Will plot agent by reward, for each level of Group

# Group controls
fplt.agent.reward1 <- 
  data.force                                        %>%
  dplyr::filter(Group == 1)                         %>%
  group_by(ID, Agent, Reward)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
  ggplot(., aes(x = Reward, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Reward level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + 
    ylim(0,1) +
    ggtitle("Agent & Reward: Controls") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


fplt.agent.reward2 <- 
  data.force                                        %>%
  dplyr::filter(Group == 2)                         %>%
  group_by(ID, Agent, Reward)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
  ggplot(., aes(x = Reward, y = mean_force, fill = Agent)) +
    geom_bar(stat =  "summary", fun.y = "mean", position=position_dodge()) +
    geom_errorbar(stat = "summary", width = 0.2, position=position_dodge(0.9)) +
    ylab("Normalised force") +
    xlab("Reward level") +
    scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
    scale_fill_manual(values=npgAgentPalette, labels = c("Self", "Other")) + 
    ylim(0,1) +
    ggtitle("Agent & Reward: Patients") +
    theme(text = textOption, plot.title = element_text(hjust = 0.5))


forceReward <- ggarrange(fplt.agent.reward1, 
                fplt.agent.reward2,
                nrow = 1, ncol = 2, 
                common.legend = TRUE, legend = "right")

ggdraw(forceReward)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceReward.pdf", plot = forceReward, width = 12, height = 8, units = c("in"), dpi = 300)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceReward.png", plot = forceReward, width = 12, height = 8, units = c("in"), dpi = 300)


```

```{r}

fplt.agent.reward1 <- 
  data.force                                        %>%
  dplyr::filter(Group == 1)                         %>%
  group_by(ID, Agent, Reward)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
    ggplot(., aes(x = Reward, y = mean_force, color = Agent)) + 
        geom_errorbar(stat = "summary", width = 0.2, position=pd) +
        geom_line(stat =  "summary", fun.y = "mean", size = pointSize) +
        geom_point(stat =  "summary", fun.y = "mean", size = pointSize, position=pd) +
        scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
        scale_color_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
        ggtitle("Agent & force: Controls") +
        ylim(0.4, 0.6) +
        theme(text = textOption, plot.title = element_text(hjust = 0.5))

fplt.agent.reward2 <- 
  data.force                                        %>%
  dplyr::filter(Group == 2)                         %>%
  group_by(ID, Agent, Reward)                       %>%
  dplyr::summarise(mean_force = mean(Force_norm))   %>%
    ggplot(., aes(x = Reward, y = mean_force, color = Agent)) + 
        geom_errorbar(stat = "summary", width = 0.2, position=pd) +
        geom_line(stat =  "summary", fun.y = "mean", size = 6) +
        geom_point(stat =  "summary", fun.y = "mean", size = 6, position=pd) +
        scale_x_discrete(labels = c("1", "2", "3", "4", "5")) +
        scale_color_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
        ggtitle("Agent & force: Patients") +
        ylim(0.4, 0.6) +
        theme(text = textOption, plot.title = element_text(hjust = 0.5))

forceReward <- ggarrange(fplt.agent.reward1, 
                fplt.agent.reward2,
                nrow = 1, ncol = 2, 
                common.legend = TRUE, legend = "right")

ggdraw(forceReward)

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/forceReward.pdf", plot = forceReward, width = 12, height = 8, units = c("in"), dpi = 300)

```


#### Post-hoc comparisons of force data

**3-way interactions**

```{r}

#### post-hoc tests on the force model

### 3-way interactions


## Group*Agent*Effort 

## extracts marginal effects for the 3-way interaction and then contrasts by Group level
# in other words, it tests the agent*effort interaction at each level of group

f.emms.3way1 <- emmeans(model.force, 
                       ~ Group*Agent*Effort) 

f.con.3way1 <- as.data.frame(contrast(f.emms.3way1, 
                                      interaction = c( "poly"), by = "Group")
  )                                               %>%
  dplyr::filter(Effort_poly == "linear")          %>%  
  dplyr::select(-Agent_poly, -Effort_poly)        %>%  
  mutate(Group = as.numeric(Group))               %>% # doing this so i can round to 3dp below
  round(.,3)                                      %>% # round to 3 decimal places
  mutate(Group = case_when(Group == 1 ~ "Controls",
                           Group == 2 ~ "Patients"))        # replaces 1&2s with self&other
                  
# makes a pretty table
kable(f.con.3way1, 
      caption = "Force data Post-hoc comparisons: testing the Agent*Effort interaction at each level of Group") %>% 
  footnote("p-values uncorrected") %>%
  kable_styling()


## Group*Agent*Reward 

## extracts marginal effects for the 3-way interaction and then contrasts by Group level
# in other words, it tests the agent*reward interaction at each level of group

f.emms.3way2 <- emmeans(model.force, 
                       ~ Group*Agent*Reward) 

f.con.3way2 <- as.data.frame(contrast(f.emms.3way2, 
                                      interaction = c( "poly"), by = "Group")
  )                                               %>%
  dplyr::filter(Reward_poly == "linear")          %>%  
  dplyr::select(-Agent_poly, -Reward_poly)        %>%  
  mutate(Group = as.numeric(Group))               %>% # doing this so i can round to 3dp below
  round(.,3)                                      %>% # round to 3 decimal places
  mutate(Group = case_when(Group == 1 ~ "Controls",
                           Group == 2 ~ "Patients"))        # replaces 1&2s with self&other
                  
# makes a pretty table
kable(f.con.3way2, 
      caption = "Force data Post-hoc comparisons: testing the Agent*Reward interaction at each level of Group") %>% 
  footnote("p-values uncorrected") %>%
  kable_styling()


## Agent*Effort*Reward 
##extracts marginal effects for the 3-way interaction and then contrasts by Reward level
# in other words, it tests the agent*effort interaction at each level of reward

f.emms.3way3 <- emmeans(model.force, 
                       ~ Agent*Effort*Reward) 

f.con.3way3 <- as.data.frame(contrast(f.emms.3way3, 
                                      interaction = c( "poly"), by = "Reward")
  )                                               %>%
  dplyr::filter(Effort_poly == "linear")          %>%  
  dplyr::select(-Agent_poly, -Effort_poly)        %>%  
  mutate(Reward = as.numeric(Reward))                  

# makes a pretty table
kable(round(f.con.3way3, 3), 
      caption = "Force data Post-hoc comparisons: testing the Agent*Effort interaction at each level of Reward") %>% 
  footnote("p-values uncorrected") %>%
  kable_styling()


## Group*Effort*Reward 

## extracts marginal effects for the 3-way interaction and then contrasts by Group level
# in other words, it tests the agent*reward interaction at each level of group

f.emms.3way4 <- emmeans(model.force, 
                       ~ Group*Effort*Reward) 

f.con.3way4 <- as.data.frame(contrast(f.emms.3way4, 
                                      interaction = c( "poly"), by = "Effort")
  )                                             %>%
  dplyr::filter(Reward_poly == "linear")          %>%  
  dplyr::select(-Group_poly, -Reward_poly)        %>%                                       
  mutate(Reward = as.numeric(Effort)) 
 
  # mutate(Group = as.numeric(Group))               %>% # doing this so i can round to 3dp below
  #round(.,3) 
  #mutate(Group = case_when(Group == 1 ~ "Controls", Group == 2 ~ "Patients"))        # replaces 1&2s with self&other
                  
# makes a pretty table
kable(f.con.3way4, 
      caption = "Force data Post-hoc comparisons: testing the Effort*Reward interaction at each level of Group") %>% 
  footnote("p-values uncorrected") %>%
  kable_styling()

```


**2-way interactions**


```{r}

### 2-way interaction: Group*Agent

f.emms.groupAgent<- emmeans(model.force, ~ Group*Agent)

f.con.groupAgent <- as.data.frame(contrast(
  f.emms.groupAgent, interaction = c( "poly"), by = "Group")
  )                                               %>%
  dplyr::select(-Agent_poly)                      %>% 
  mutate(Group = as.numeric(Group))               %>% 
  round(.,3)                                      %>%
  mutate(Group = case_when(Group == 1 ~ "Controls",
                           Group == 2 ~ "Patients")) 

# makes a pretty table
kable(f.con.groupAgent, 
      caption = "Force data: Post-hoc comparisons: testing the Agent effect at each level of Group") %>% 
  footnote(c("p-values uncorrected")) %>%
  kable_styling()


### 2-way interaction: Group*Effort

f.emms.groupEffort <- emmeans(model.force, ~ Group*Effort)

f.con.groupEffort <- as.data.frame(contrast(
  f.emms.groupEffort, interaction = c( "poly"), by = "Effort")
  )                                               %>%
  dplyr::select(-Group_poly)                      %>% 
  mutate(Effort = as.numeric(Effort))             %>%  
  round(.,3)                                      # round to 3 decimal places

# makes a pretty table
kable(f.con.groupEffort, 
      caption = "Force data: Post-hoc comparisons: testing the Group effect at each level of Effort") %>% 
  footnote(c("p-values uncorrected")) %>%
  kable_styling()


### 2-way interaction: Group*Reward

f.emms.groupReward <- emmeans(model.force, ~ Group*Reward)

f.con.groupReward <- as.data.frame(contrast(
  f.emms.groupReward, interaction = c( "poly"), by = "Reward")
  )                                               %>%
  dplyr::select(-Group_poly)                      %>% 
  mutate(Reward = as.numeric(Reward))             %>%  
  round(.,3)                                      # round to 3 decimal places

# makes a pretty table
kable(f.con.groupReward, 
      caption = "Force data: Post-hoc comparisons: testing the Group effect at each level of Reward") %>% 
  footnote(c("p-values uncorrected")) %>%
  kable_styling()

### 2-way interaction: Agent*Effort

f.emms.agentEffort <- emmeans(model.force, ~ Agent*Effort)

f.con.agentEffort <- as.data.frame(contrast(
  f.emms.agentEffort, interaction = c( "poly"), by = "Effort")
  )                                               %>%
  dplyr::select(-Agent_poly)                      %>% 
  mutate(Effort = as.numeric(Effort))             %>%  
  round(.,3)                                      # round to 3 decimal places

# makes a pretty table
kable(f.con.agentEffort, 
      caption = "Post-hoc comparisons: testing the Agent effect at each level of Effort") %>% 
  footnote(c("p-values uncorrected")) %>%
  kable_styling()


### 2-way interaction: Agent*Reward

f.emms.agentReward <- emmeans(model.force, ~ Agent*Reward)

f.con.agentReward <- as.data.frame(contrast(
  f.emms.agentReward, interaction = c( "poly"), by = "Reward")
  )                                               %>%
  dplyr::select(-Agent_poly)                      %>% 
  mutate(Reward = as.numeric(Reward))             %>%  
  round(.,3)                                      # round to 3 decimal places

# makes a pretty table
kable(f.con.agentReward, 
      caption = "Post-hoc comparisons: testing the Agent effect at each level of Reward") %>% 
  footnote(c("p-values uncorrected")) %>%
  kable_styling()

```




### t-test on the success rates across groups
```{r}

## t-test on the success rates across groups

success <-
  data.choice %>%
  mutate(Success = as.numeric(Success)-1) %>%
  group_by(ID, Group) %>%
  dplyr::summarise(mean_succ = mean(Success)) 

success.t <- t.test(success$mean_succ[success$Group == 1], 
                    success$mean_succ[success$Group == 2])

describeBy(success$mean_succ, success$Group)

summary(success.t)
## no differences in success across groups

```

## Analysis of discount (k) parameters from the winning model (2k1B)

### Load and organise data
Okay, in the code below I don't really know which variables you're interested in regressing against the k-values, so I'm just going to select one of them and comment it so that it's obvious how to include others

```{r}

### Load the k parameters and organise the data


# loads data
df.k <- qDat %>%
  
  # include any other variables of interest in the line below
  
  dplyr::select(ID, K2B1_self, K2B1_other, Corrected_DAT_Executive_Striatum) %>% # DAT_level_Putamen
  gather(key = "agent", value = "k", K2B1_self:K2B1_other) %>%   # long format 
  mutate(agent = factor(agent))                      %>%   # factorise agent
  mutate(ID = factor(ID))                                  # factorise ID


```

### Wilcoxon signed rank test on self and other ks (for patients - df.k)
```{r}

##### there seems to be an error that I don't know what it means. But it still seem to be giving an output so \_0_/

# self vs other k in the patient group
wil.k <- wilcox.test(df.k$k[df.k$agent == "K2B1_self"], # self
            df.k$k[df.k$agent == "K2B1_other"],  # other
            paired = TRUE, conf.int = TRUE)

wil.k

``` 

### Robust regression on k parameters
```{r}

### Use robust linear mixed effects model to analyse the data due to heavily skewed distribution

## as with lmer, you can just add predictors in the model below. You need to have    put them in the df.k in the code chunk about
model.rlmer.k <- rlmer(k ~ agent*Corrected_DAT_Executive_Striatum + (1|ID), data = df.k)

## Pull out stats - this calculates p-values using the function in the first code    chunk
stats.2k <- stats.rlmerMod(model.rlmer.k)
stats.2k

### Plot the ks

## This code produces a plot with a regression line of k ~ DAT (or whatever continuous variable you've put into your model), for each level of agent


ggplot(df.k, aes(x=Corrected_DAT_Executive_Striatum, y = k, colour = agent, fill = agent)) + 
  
  # so this next line uses rlm instead of rlmer because rlmer isn't implemented. But it's actually okay in this case because for each level of agent, each ID only has one value, making rlm the correct choice
  geom_smooth(method = "rlm") +   
  geom_point(alpha = 0.6) 


#--
kSelf <- df.k[ which(df.k$agent=='K2B1_self'), ]
cor.test(kSelf$Corrected_DAT_Executive_Striatum, kSelf$k, method=c("kendall")) # , "spearman"

kOther <- df.k[ which(df.k$agent=='K2B1_other'), ]
cor.test(kSelf$Corrected_DAT_Executive_Striatum, kSelf$k, method=c("kendall")) 

```



### Robust regression on k parameters
```{r}

# caudate DAT, caudate Vol, whole brain FA

### Load the k parameters and organise the data

df.k <- qDat %>%
  dplyr::select(ID, K2B1_self, K2B1_other, api_emotional) %>% 
  gather(key = "agent", value = "k", K2B1_self:K2B1_other)        %>%   # long format 
  mutate(agent = factor(agent))                                    %>%   # factorise agent
  mutate(ID = factor(ID))                                  # factorise ID

measure=df.k$api_emotional
df.k$nm=((measure - 4)*(-1)) # review this https://stackoverflow.com/questions/26877917/reverse-scoring-items




### Use robust linear mixed effects model to analyse the data due to heavily skewed distribution
## as with lmer, you can just add predictors in the model below. You need to have put them in the df.k in the code chunk above
model.rlmer.k <- rlmer(k ~ agent*nm + (1|ID), data = df.k)

## Pull out stats - this calculates p-values using the function in the first code    chunk
stats.2k <- stats.rlmerMod(model.rlmer.k)
stats.2k

### Plot the ks
## This code produces a plot with a regression line of k ~ DAT (or whatever continuous variable you've put into your model), for each level of agent

ggplot(df.k, aes(x=nm, y = k, colour = agent, fill = agent)) + 
  
# so this next line uses rlm instead of rlmer because rlmer isn't implemented. But it's actually okay in this case because for each level of agent, each ID only has one value, making rlm the correct choice
  geom_smooth(method = "rlm") +   
  geom_point(alpha = 0.6) 

```


### 
```{r}

newdata <- qSoc.df[ which(qSoc.df$Group=='PAT'),]

M_model <- lm(K2B1_other ~ Mayo, data=newdata)
#anova(model)
Anova(M_model, type="III")


```


### DAT & LARS-C
```{r}

### Load the k parameters and organise the data

df.k <- qDat %>%
  dplyr::select(ID, Corrected_DAT_NucAcc, LARSCTotal) %>% 
  mutate(ID = factor(ID))                            

df.k$Group <- "TBI"
summary(lm(LARSCTotal ~ Corrected_DAT_NucAcc, data = df.k))
aov(lm(LARSCTotal ~ Corrected_DAT_NucAcc, data = df.k))

  pmain <- ggplot(df.k, aes(x = LARSCTotal, y = Corrected_DAT_NucAcc, color = Group)) +
            geom_smooth(method=lm) +
            geom_jitter() +
            fillPalette +   
            colPalette +
            #scale_colour_manual(values=npgGroupPalette) + 
            ylab("DAT: NucAC") +
            xlab("LARS-CG") +
            theme(text = element_text(size=20), legend.text = element_text(size = 16))
 

  xdens <- axis_canvas(pmain, axis = "x")+
    geom_density(data = df.k, aes(x = LARSCTotal, fill = Group), alpha = 0.7, size = 0.2) +
    ggpubr::fill_palette("jco") +
    fillPalette +
    #scale_fill_manual(values=npgGroupPalette) +
    theme(text = element_text(size=18), legend.text = element_text(size = 14))
  
# Need to set coord_flip = TRUE, if you plan to use coord_flip()
  ydens <- axis_canvas(pmain, axis = "y", coord_flip = TRUE)+
    geom_density(data = df.k, aes(x = Corrected_DAT_NucAcc, fill = Group), alpha = 0.7, size = 0.2)+
    coord_flip()+
    ggpubr::fill_palette("jco") +
    fillPalette +
    #scale_fill_manual(values=npgGroupPalette) +
    theme(text = element_text(size=18), legend.text = element_text(size = 14))
  
  
  p1 <- insert_xaxis_grob(pmain, xdens, grid::unit(.2, "null"), position = "top")
  p2 <- insert_yaxis_grob(p1, ydens, grid::unit(.2, "null"), position = "right")
  ggdraw(p2)  
  
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/NuAc_LARSCG.pdf", plot = p2, width = 12, height = 8, units = c("in"), device = cairo_pdf ) # 
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/NuAc_LARSCG.jpg", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300, type = "cairo")

```

### DAT & FrSBe_OtherTotNow

```{r} 

### Load the k parameters and organise the data

df.k <- qDat %>%
  dplyr::select(ID, K2B1_self, K2B1_other, FrSBe_Other_D_Now) %>% 
  gather(key = "agent", value = "k", K2B1_self:K2B1_other)        %>%   # long format 
  mutate(agent = factor(agent))                                    %>%   # factorise agent
  mutate(ID = factor(ID))                                  # factorise ID

### Use robust linear mixed effects model to analyse the data due to heavily skewed distribution
## as with lmer, you can just add predictors in the model below. You need to have put them in the df.k in the code chunk above
model.rlmer.k <- rlmer(k ~ agent*FrSBe_Other_D_Now + (1|ID), data = df.k)

## Pull out stats - this calculates p-values using the function in the first code    chunk
stats.2k <- stats.rlmerMod(model.rlmer.k)
stats.2k

### Plot the ks
## This code produces a plot with a regression line of k ~ DAT (or whatever continuous variable you've put into your model), for each level of agent

  pmain <- ggplot(df.k, aes(x = k, y = FrSBe_Other_D_Now, color = agent)) +
            geom_smooth(method=lm) +
            geom_jitter() +
            scale_colour_manual(values=rev_npgAgentPalette) +   
            #scale_colour_manual(values=npgGroupPalette) + 
            ylab("Dysexecutive - Other") +
            xlab("k") +
            theme(text = element_text(size=20), legend.text = element_text(size = 16))
 

  xdens <- axis_canvas(pmain, axis = "x")+
    geom_density(data = df.k, aes(x = k, fill = agent), alpha = 0.7, size = 0.2) +
    ggpubr::fill_palette("jco") +
    scale_fill_manual(values=rev_npgAgentPalette) +
    #scale_fill_manual(values=npgGroupPalette) +
    theme(text = element_text(size=18), legend.text = element_text(size = 14))
  
# Need to set coord_flip = TRUE, if you plan to use coord_flip()
  ydens <- axis_canvas(pmain, axis = "y", coord_flip = TRUE)+
    geom_density(data = df.k, aes(x = FrSBe_Other_D_Now, fill = agent), alpha = 0.7, size = 0.2)+
    coord_flip()+
    ggpubr::fill_palette("jco") +
    scale_fill_manual(values=rev_npgAgentPalette) +
    #scale_fill_manual(values=npgGroupPalette) +
    theme(text = element_text(size=18), legend.text = element_text(size = 14))
  
  
  p1 <- insert_xaxis_grob(pmain, xdens, grid::unit(.2, "null"), position = "top")
  p2 <- insert_yaxis_grob(p1, ydens, grid::unit(.2, "null"), position = "right")
  ggdraw(p2)  
  
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/k_FrSBe_OtherTotNow.pdf", plot = p2, width = 12, height = 8, units = c("in"), device = cairo_pdf ) # 
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/assets/k_FrSBe_OtherTotNow.jpg", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300, type = "cairo")


```


# Pat's extract random effects
To get the models to include random effects calculated for the different variables you need to include the random effects of each subject in the model, you can not include them for the main analysis you report in the paper but you will need to include them to get out the random effects of each effect for each participant. I have added the extra necessary part in blue. This will allow an individual participant main effect of reward, main effect of effort, agent and interactions. 
```{r}

# Define the models -  commented out because they are loaded below

# full model
pfe.model.3wayfull.rand <- glmer(Choice ~ Agent*Effort + Agent*Reward + (1 + Agent*Effort + Agent*Reward| ID),
                     data = pfe.data.pm.glmm, family = 'binomial',
                     control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

pfe.rand.effects <- ranef(pfe.model.3wayfull.rand)[["ID"]]
pfe.data.raw <- subset(data.pm, Group > 1)
pfe.ids <- as.data.frame(unique(pfe.data.raw$ID))
names(pfe.ids)[1] <- "ID"
pfe.pm.ids <- as.data.frame(unique(pfe.data.raw$PM_ID))
names(pfe.pm.ids)[1] <- "PM_ID"
pfe.rand.effects.ids <- bind_cols(pfe.pm.ids, pfe.ids, pfe.rand.effects)
write.csv(pfe.rand.effects.ids, "exl_lesion_random.csv")
pfe.coeffs <- coef(summary(pfe.model.3wayfull.rand))
#write.csv(pfe.coeffs, "exl_lesion_fixed.csv)

```


```{r}

# Define the models -  commented out because they are loaded below

# full model
pfe.model.3wayfull.rand <- glmer(Choice ~ Agent*Effort + Agent*Reward + (1 + Agent*Effort + Agent*Reward| ID),
                     data = data.choice, family = 'binomial',
                     control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

pfe.rand.effects <- ranef(pfe.model.3wayfull.rand)[["ID"]]
pfe.data.raw <- subset(data.choice, Group > 1)
pfe.ids <- as.data.frame(unique(pfe.data.raw$ID))
names(pfe.ids)[1] <- "ID"
pfe.pm.ids <- as.data.frame(unique(pfe.data.raw$ID))

names(pfe.pm.ids)[1] <- "PM_ID"
pfe.rand.effects.ids <- bind_cols(pfe.pm.ids, pfe.ids, pfe.rand.effects)

#write.csv(pfe.rand.effects.ids, "exl_lesion_random.csv")
pfe.coeffs <- coef(summary(pfe.model.3wayfull.rand))
#write.csv(pfe.coeffs, "exl_lesion_fixed.csv)

```

---

### Jan robust regression on k parameters (inc. newly processed control structural data)
```{r}

# caudate DAT, caudate Vol, whole brain FA

### Load the k parameters and organise the data

df.k <- qSoc.df %>%
  dplyr::select(ID, Group, K2B1_self, K2B1_other, api_social)   %>% 
  gather(key = "agent", value = "k", K2B1_self:K2B1_other)      %>%   # long format 
  mutate(agent = factor(agent))                                    %>%   # factorise agent
  mutate(ID = factor(ID))                                  # factorise ID

# Correcting inverted responses
measure=df.k$api_social
df.k$nm=((measure - 4)*(-1)) # review this https://stackoverflow.com/questions/26877917/reverse-scoring-items

### Use robust linear mixed effects model to analyse the data due to heavily skewed distribution
## as with lmer, you can just add predictors in the model below. You need to have put them in the df.k in the code chunk above
model.rlmer.k <- rlmer(k ~ agent*nm*Group + (1|ID), data = df.k)

## Pull out stats - this calculates p-values using the function in the first code chunk
stats.2k <- stats.rlmerMod(model.rlmer.k)
stats.2k

### Plot the ks
## This code produces a plot with a regression line of k ~ DAT (or whatever continuous variable you've put into your model), for each level of agent

p1 <- ggplot(df.k, aes(x=k, y = nm, colour = agent, shape = Group)) + 
  facet_grid(. ~ Group) +
  # so this next line uses rlm instead of rlmer because rlmer isn't implemented. 
  # But it's actually okay in this case because for each level of agent, each ID only has one value, making rlm the correct choice
  geom_smooth(method = "rlm") +   
  geom_point(alpha = 0.6, size = 2) 
  #+
  #xlim(0, 0.5)

p1

```

## Daves desire for a null imaging plot
```{r}

### Load the k parameters and organise the data
df.k <- qSoc.df %>%
  dplyr::select(ID, Group, K2B1_self, K2B1_other, vol_WM_VOL)   %>% 
  gather(key = "agent", value = "k", K2B1_self:K2B1_other)      %>%   # long format 
  mutate(agent = factor(agent))                                    %>%   # factorise agent
  mutate(ID = factor(ID))                                  # factorise ID

var1 <- df.k$vol_WM_VOL
# ### Use robust linear mixed effects model to analyse the data due to heavily skewed distribution
# ## as with lmer, you can just add predictors in the model below. You need to have put them in the df.k in the code chunk above
# model.rlmer.k <- rlmer(k ~ agent*var1*Group + (1|ID), data = df.k)
# 
# ## Pull out stats - this calculates p-values using the function in the first code chunk
# stats.2k <- stats.rlmerMod(model.rlmer.k)
# stats.2k

### Plot the ks
## This code produces a plot with a regression line of k ~ DAT (or whatever continuous variable you've put into your model), for each level of agent

p1 <- ggplot(df.k, aes(x=k, y = var1, colour = agent, shape = Group)) + 
  facet_grid(. ~ Group) +
  geom_smooth(method = "rlm") +   
  geom_point(alpha = 0.6, size = 2) +
  xlim(0, 0.7) +
  xlab("Discounting rate (K)") +
  ylab("White matter volume") +
  scale_color_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p1

model.lmer.k <- lmer(k ~ var1*agent*Group + (1|ID), data = df.k)
Anova(model.lmer.k, type="III")
#summary(model.lmer.k)
lsm = lsmeans(model.lmer.k, ~agent|Group) # 
contrast(lsm, interaction = "pairwise", adjust="tukey")

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/Agent-Group-K.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)
```


# FA Agent*Group*K

```{r}

### Load the k parameters and organise the data
df.k <- qSoc.df %>%
  dplyr::select(ID, Group, K2B1_self, K2B1_other, FA_skeleton)   %>% 
  gather(key = "agent", value = "k", K2B1_self:K2B1_other)      %>%   # long format 
  mutate(agent = factor(agent))                                    %>%   # factorise agent
  mutate(ID = factor(ID))                                  # factorise ID

var1 <- df.k$FA_skeleton
### Use robust linear mixed effects model to analyse the data due to heavily skewed distribution
## as with lmer, you can just add predictors in the model below. You need to have put them in the df.k in the code chunk above
# model.rlmer.k <- rlmer(k ~ agent*var1*Group + (1|ID), data = df.k)
# ## Pull out stats - this calculates p-values using the function in the first code chunk
# stats.2k <- stats.rlmerMod(model.rlmer.k)
# stats.2k

model.lmer.k <- lmer(k ~ agent*var1*Group + (1|ID), data = df.k)
Anova(model.lmer.k, type="III")
#summary(model.lmer.k)
lsm = lsmeans(model.lmer.k, ~Group|agent) # 
contrast(lsm, interaction = "pairwise", adjust="tukey")



### Plot the ks
## This code produces a plot with a regression line of k ~ DAT (or whatever continuous variable you've put into your model), for each level of agent

p1 <- ggplot(df.k, aes(x=k, y = var1, colour = agent, shape = Group)) + 
  facet_grid(. ~ Group) +
  geom_smooth(method = "lm") +   # rlm
  geom_point(alpha = 0.6, size = 2) +
  xlim(0, 0.7) +
  xlab("Discounting rate (K)") +
  ylab("White matter FA") +
  scale_color_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p1

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/Agent-Group-K-FA.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)
```


# ROI

TPJ_sphere_35_74_87: NULL
DMPFC_sphere_88_150_89: NULL
ACCg_sphere_87_166_113: NULL
sgACC_sphere_93_134_61: NULL

```{r}

### Load the k parameters and organise the data
df.k <- qSoc.df %>%
  dplyr::select(ID, Group, K2B1_self, K2B1_other, sgACC_sphere_93_134_61)   %>% 
  gather(key = "agent", value = "k", K2B1_self:K2B1_other)      %>%   # long format 
  mutate(agent = factor(agent))                                    %>%   # factorise agent
  mutate(ID = factor(ID))   

df.k$sgACC_sphere_93_134_61 <- as.numeric(df.k$sgACC_sphere_93_134_61)
df.k <- na.omit(df.k)
var1 <- df.k$sgACC_sphere_93_134_61

model.lmer.k <- lmer(k ~ agent*var1*Group + (1|ID), data = df.k)
Anova(model.lmer.k, type="III")
#summary(model.lmer.k)
lsm = lsmeans(model.lmer.k, ~Group|agent) # 
contrast(lsm, interaction = "pairwise", adjust="tukey")

# plot
p1 <- ggplot(df.k, aes(x=k, y = var1, colour = agent, shape = Group)) + 
  facet_grid(. ~ Group) +
  geom_smooth(method = "lm") +   # rlm
  geom_point(alpha = 0.6, size = 2) +
  xlim(0, 0.7) +
  xlab("Discounting rate (K)") +
  ylab("White matter FA") +
  scale_color_manual(values=npgAgentPalette, labels = c("Self", "Other")) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p1

#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch5 Social decision making/figures/Agent-Group-K-FA.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)
```






