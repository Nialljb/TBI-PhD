---
title: "Cognitrack Metacognition analysis"
author: "Niall Bourke"
date: "29th December 2019"
Version: "v3 (June 2020)"
output: html_notebook
---

This notebook extacts the cleaned task data from cognitrack and merges it with the metacognitive (confidence judgments) made by participants after playing the tasks. This was previously parsed with matlab and saved as csv files.  

The loaded dataset is the full download from the website for October 2019 - All other measures could be extracted from the cleaned dataset saved out. 

### Clear workspace
```{r}
# ---- setup ----
rm(list= ls()) # clear screen
options(scipen=999) # gets rid of scientific notation
```
To clear individual objects from workspace:
rm(medianCongRT, medianInCongRT)

### Load packages
```{r warning=FALSE}
# load packages useful for analysis
# If not previosuly installed :  install.packages(name of package)

# Data wrangling
library(plyr)
library(dplyr)
library(tidyverse)
library(tidyr)
library(reshape2)

# make pretty figures
library(ggplot2) 
library(ggpubr)
library(cowplot)

# Stats
library(psych) # good for describeBy command - doesnt display well in r update anymore
library(car)
library(lme4)
library(lsmeans)


```



```{r, Formating options}

if (!require("RColorBrewer")) {
install.packages("RColorBrewer")
library(RColorBrewer)
}

library("ggsci")

## Formating options ##
# show_col(pal_npg("nrc")(10))
myPalette <- c("#3399FF","#FF0000")
fillPalette <- (scale_fill_npg()) # (scale_fill_rickandmorty())
colPalette <- (scale_color_npg()) # (scale_color_rickandmorty())
npgGroupPalette <- c("#4DBBD5FF","#E64B35FF")
npgAgentPalette <- c("#00A087FF","#3C5488FF")

# Other colour options
# scale_color_tron() # Good with dark theme

# The errorbars overlapped, so use position_dodge to move them horizontally
pd <- position_dodge(0.1) # move them .05 to the left and right 
ebSize <- 1
fpSize <- 2
pointSize <- 3

# Font type & size
textOption <- element_text(family="Times", size = 22)
facetText  <- element_text( size = 20) #family="Times",

```

# Data Parsing

## Load in data
Raw task data is loaded in and split into df per task (this was done as some have non standard headings of intetest & to match metaCog data import). These will be merged later on. The metacognition data import is after a matlab parsing. This data should be timepoint 1. 

```{r}

# Task data
rawData <- read.csv("~/Google\ Drive/emo/data/clean.raw.data.csv")
# split df
motorControl.raw <- rawData[ which(rawData$Task=='Motor Control (i4i)'),]
srt.raw <- rawData[ which(rawData$Task=='SRT (i4i)'),]
crt.raw <- rawData[ which(rawData$Task=='CRT (i4i)'),]
targetDetection.raw <- rawData[ which(rawData$Task=='Target Detection (i4i)'),]
pal.raw <- rawData[ which(rawData$Task=='PAL (i4i)'),]
trails.raw <- rawData[ which(rawData$Task=='AutoGenerated (i4i_trailMaking)'),]
emD.raw <- rawData[ which(rawData$Task=='Emotional Dicrimination (i4i)'),]
emC.raw <- rawData[ which(rawData$Task=='AutoGenerated (i4i_emotionalControl)'),]

```


## Sort out timepoints function
Input is a dataframe with "ID" column and "task.timeStamp"
1. drops redundent factor levels
2. changes date to standard format
3. Orders this new date per subject
4. Creates timepoint var

```{r}

fixCognitrackDate <- function(input) {
  
  out.df=NULL
  
  input <- droplevels(input)
  for (val in levels(input$ID)) {
    subj <- filter(input, grepl(val, ID))
    subj$task.timeStamp <- factor(subj$task.timeStamp)
    #print(val)
    
    # Loop over original timeStamps and change to someting more usful
    n = length(subj$task.timeStamp)
    for (i in 1:n) {
    tryCatch({
      tpVar <- as.character(subj$task.timeStamp[i])
      tmpVar <- strsplit(tpVar," ")[[1]]
      shortDate <- paste(tmpVar[2:4], sep = " ", collapse = "")
      timeVar <- tmpVar[5]
      DateVar <- as.Date(shortDate, format = "%B %d %Y")
      subj$task.newTimeStamp[i] <- as.character(DateVar)

      #newDate <- as.Date(shortDate, format = "%B %d %Y")
      #DateTime <- paste(Date, time, sep = " ")
      #print(DateTime)
      #newDateTime <- as.POSIXlt(timeVar)
      #print(newDateTime)
      #subj$task.time[i] <- as.character(newDateTime) # as.character(   stringsAsFactors = FALSE

        }, error=function(e){cat("ERROR :", val, conditionMessage(e), "\n")})
    }
    
    # Order timestamps and create timepoint variable
    subj[order(subj$task.newTimeStamp),] #, as.factor(subj$task.time)
    
    m = length(subj$task.newTimeStamp)
    for (ii in 1:m) {
    tryCatch({
        subj$timepoint[ii] <- ii
        }, error=function(e){cat("ERROR :", val, conditionMessage(e), "\n")})
    }
    # On each loop bind each observation with the new variables to a dataframe
    out.df <- rbind(out.df,subj)  %>% 
          distinct()
  }
  return(out.df)
}

```


## Loop over tasks and parse with conditional statements 
1. For each task, check if task with conditional output
2. remove redundent factor levels. 
3. Assign variables of interst from row values (* There is definatly a better way to do this in the tidyverse).
4. Drop nuisance variables from these tmp df and merge

```{r}

df.task <- list(emC.raw, emD.raw, pal.raw, motorControl.raw, srt.raw, crt.raw, targetDetection.raw, trails.raw)
df.taskName <- list("emC.raw", "emD.raw", "pal.raw", "motorControl.raw", "srt.raw", "crt.raw", "targetDetection.raw", "trails.raw") # need to match with task list

for (ii  in 1:length(df.task)) {
        
        if (df.taskName[ii]=="emC.raw" || df.taskName[ii]=="emD.raw") {
         #print("TRUE")
        
        # Drop redundent factor levels
        data.x <- data.frame(df.task[ii])
        data_drop <- droplevels(data.x)
        # Subset data
        total <- data_drop[which(data_drop$Measure=="SummaryScore"),]
        medianCongRT <- data_drop[which(data_drop$Measure=="Scores.medianCongRT"),]
        medianInCongRT <- data_drop[which(data_drop$Measure=="Scores.medianInCongRT"),]
        congAcc <- data_drop[which(data_drop$Measure=="Scores.congAcc"),]
        inCongAcc <- data_drop[which(data_drop$Measure=="Scores.inCongAcc"),]
        tStamp <- data_drop[which(data_drop$Measure=="timeStamp"),]

        # Drop some variables
        myVars <- c("Value", "Username.String", "interview.uuid", "Group")
        total <- total[myVars]
        medianCongRT <- medianCongRT[myVars]
        medianInCongRT <- medianInCongRT[myVars]
        congAcc <- congAcc[myVars]
        inCongAcc <- inCongAcc[myVars]
        tStamp <-  tStamp[myVars]
     
        # Adjust col names 
        colnames(total)[colnames(total)=="Value"] <- "total"
        colnames(medianCongRT)[colnames(medianCongRT)=="Value"] <- "medianCongRT"
        colnames(medianInCongRT)[colnames(medianInCongRT)=="Value"] <- "medianInCongRT"
        colnames(congAcc)[colnames(congAcc)=="Value"] <- "congAcc"
        colnames(inCongAcc)[colnames(inCongAcc)=="Value"] <- "inCongAcc"
        colnames(tStamp)[colnames(tStamp)=="Value"] <- "task.timeStamp"
  
        # merge data - tidyverse
        tmp.df <- list(total,medianCongRT,medianInCongRT,congAcc,inCongAcc,tStamp) %>% reduce(left_join, by = "interview.uuid") 
        colnames(tmp.df)[colnames(tmp.df)=="Username.String.x"] <- "ID"
        colnames(tmp.df)[colnames(tmp.df)=="Group.x"] <- "Group"       
        dropCol <- c("Username.String.y", "Group.y", "Username.String.x.x", "Group.x.x", "Username.String.y.y", "Group.y.y", "Username.String.x.x.x", "Group.x.x.x", "Username.String.y.y.y", "Group.y.y.y", "interview.uuid")
        out.tmp <- tmp.df[,!(names(tmp.df) %in% dropCol)] %>% 
          distinct()
        out.df <- fixCognitrackDate(out.tmp)

        outname <- paste("~/Google\ Drive/emo/cognitrack/taskRaw/", df.taskName[ii], ".csv", sep = "")
        # write to csv & fix date time in matlab
        write.csv(out.df, file = outname, row.names=FALSE)            
        
                
        } else if (df.taskName[ii]=="trails.raw" ) {
         #print("FALSE")
                
        # Drop redundent factor levels
        data.x <- data.frame(df.task[ii])
        data_drop <- droplevels(data.x)
        # Subset data
        measure <- data_drop[which(data_drop$Measure=="Scores.nlCost"),]
        tStamp <- data_drop[which(data_drop$Measure=="timeStamp"),]

        # Drop some variables
        myVars <- c("Value", "Username.String", "interview.uuid", "Group")
        measure <- measure[myVars]
        tStamp <-  tStamp[myVars]
     
        # Adjust col names 
        colnames(measure)[colnames(measure)=="Value"] <- "sum.score"
        colnames(tStamp)[colnames(tStamp)=="Value"] <- "task.timeStamp"
  
        # merge data - tidyverse
        tmp.df <- list(measure,tStamp) %>% reduce(left_join, by = "interview.uuid") 
        colnames(tmp.df)[colnames(tmp.df)=="Username.String.x"] <- "ID"
        colnames(tmp.df)[colnames(tmp.df)=="Group.x"] <- "Group"       
        dropCol <- c("Username.String.y", "Group.y", "interview.uuid") # "interview.uuid" is included here as some uuids are duplicated observations
        out.tmp <- tmp.df[,!(names(tmp.df) %in% dropCol)] %>% 
          distinct()

        out.df <- fixCognitrackDate(out.tmp)

        outname <- paste("~/Google\ Drive/emo/cognitrack/taskRaw/", df.taskName[ii], ".csv", sep = "")
        # write to csv & fix date time in matlab
        write.csv(out.df, file = outname, row.names=FALSE)       
                
        } else {
                
        # Drop redundent factor levels
        data.x <- data.frame(df.task[ii])
        data_drop <- droplevels(data.x)
        # Subset data
        measure <- data_drop[which(data_drop$Measure=="SummaryScore"),]
        tStamp <- data_drop[which(data_drop$Measure=="timeStamp"),]

        # Drop some variables
        myVars <- c("Value", "Username.String", "interview.uuid", "Group")
        measure <- measure[myVars]
        tStamp <-  tStamp[myVars]
     
        # Adjust col names 
        colnames(measure)[colnames(measure)=="Value"] <- "sum.score"
        colnames(tStamp)[colnames(tStamp)=="Value"] <- "task.timeStamp"
  
        # merge data - tidyverse
        tmp.df <- list(measure,tStamp) %>% reduce(left_join, by = "interview.uuid") 
        
        colnames(tmp.df)[colnames(tmp.df)=="Username.String.x"] <- "ID"
        colnames(tmp.df)[colnames(tmp.df)=="Group.x"] <- "Group"       
        dropCol <- c("Username.String.y", "Group.y", "interview.uuid")
        
        out.tmp <- tmp.df[,!(names(tmp.df) %in% dropCol)] %>% 
          distinct()
        
        out.df <- fixCognitrackDate(out.tmp)
        
        outname <- paste("~/Google\ Drive/emo/cognitrack/taskRaw/", df.taskName[ii], ".csv", sep = "")
        # write to csv & fix date time in matlab
        write.csv(out.df, file = outname, row.names=FALSE)
        
 }
}

```



# Reading dataframes for analysis
All timepoints - Check aligned correctly 
```{r}

demo.df <- read.csv('~/Google Drive/Imperial/PhD/Thesis/analysis/app/cognitrackDemo.csv')

emd.parse <-read.csv("~/Google\ Drive/Imperial/emo/cognitrack/taskRaw/emD.raw.csv")  
emc.parse <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/taskRaw/emC.raw.csv") 
srt.parse <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/taskRaw/srt.raw.csv") 
crt.parse <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/taskRaw/crt.raw.csv") 
trails.parse <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/taskRaw/trails.raw.csv") 
pal.parse <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/taskRaw/pal.raw.csv")
targetDetection.parse <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/taskRaw/targetDetection.raw.csv") 
motorControl.parse <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/taskRaw/motorControl.raw.csv") 

```

Metacognition TP1
```{r}
# metacognition data
motorControl.meta <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/confidenceJudgments/meta_Motor_Control_tp1.csv")
srt.meta <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/confidenceJudgments/meta_SRT_tp1.csv")
crt.meta <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/confidenceJudgments/meta_CRT_tp1.csv")
targetDetection.meta <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/confidenceJudgments/meta_Target_Detection_tp1.csv")
pal.meta <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/confidenceJudgments/meta_PAL_tp1.csv")
trails.meta <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/confidenceJudgments/meta_Trail_Making_tp1.csv")
emD.meta <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/confidenceJudgments/meta_Emotional_Discrimination_tp1.csv")
emC.meta <- read.csv("~/Google\ Drive/Imperial/emo/cognitrack/confidenceJudgments/meta_Emotional_Control_tp1.csv")
```



## Basic demographics
```{r}

table(demo.df$Patient)
describeBy(demo.df$MonthsSinceInjury)

con.demo <- demo.df[ which(demo.df$Patient == "Healthy Volunteer"),]
pat.demo <- demo.df[ which(demo.df$Patient == "Patient"),]

table(pat.demo$Gender)
table(con.demo$Gender)

table(demo.df$Education, demo.df$Patient)

table(pat.demo$TypeOfInjury)
table(pat.demo$MechanismOfInjury)
table(pat.demo$LengthLossOfConsciousness)

describeBy(con.demo$Age)
describeBy(pat.demo$Age)

```

## CCA data frame
Divide into a behavioural dataframe & a metacognitive dataframe for CCA analysis.

1. Split into first timepoint
2. Remove duplicated observations
3. Requires renaming of certain variables into task specific names for merging.
4. Remove missing data from metacogntion df
5. drop uninteresting columns for CCA

```{r}

# list of variables to remove
drop <- c("interview.uuid", "task.timeStamp", "task.newTimeStamp", "Date")

# Emotional Discrimination  
# parse timepoint one for task, remove duplicates, rename task specific variables, drop variables
cca.emd <- emd.parse[which(emd.parse$timepoint==1),] 
  colnames(cca.emd)[colnames(cca.emd)=="medianCongRT"] <- "emd.medianCongRT" 
  colnames(cca.emd)[colnames(cca.emd)=="medianInCongRT"] <- "emd.medianInCongRT"       
  colnames(cca.emd)[colnames(cca.emd)=="congAcc"] <- "emd.congAcc"       
  colnames(cca.emd)[colnames(cca.emd)=="inCongAcc"] <- "emd.inCongAcc"     
  colnames(cca.emd)[colnames(cca.emd)=="total"] <- "emd.total"
cca.emd <- cca.emd[,!(names(cca.emd) %in% drop)]
  
# Remove missing data from metacognition, rename response var, merge with task and remove Date var    
cca.emd.meta <- na.omit(emD.meta)
colnames(cca.emd.meta)[colnames(cca.emd.meta)=="Response"] <- "emd.conf"       
emd.tp1.df <- merge(cca.emd, cca.emd.meta, by="ID")
emd.tp1.df <- emd.tp1.df[,!(names(emd.tp1.df) %in% drop)]
              
# Emotional Control  
cca.emc <- emc.parse[which(emc.parse$timepoint==1),] 
        colnames(cca.emc)[colnames(cca.emc)=="medianCongRT"] <- "emc.medianCongRT" 
        colnames(cca.emc)[colnames(cca.emc)=="medianInCongRT"] <- "emc.medianInCongRT"       
        colnames(cca.emc)[colnames(cca.emc)=="congAcc"] <- "emc.congAcc"       
        colnames(cca.emc)[colnames(cca.emc)=="inCongAcc"] <- "emc.inCongAcc" 
        colnames(cca.emc)[colnames(cca.emc)=="total"] <- "emc.total"       
cca.emc = cca.emc[,!(names(cca.emc) %in% drop)]

cca.emc.meta <- 
  emC.meta %>% 
  na.omit(emC.meta) %>% 
  dplyr::rename(., "emc.conf" = "Response") 


#colnames(cca.emc.meta)[colnames(cca.emc.meta)=="Response"] <- "emc.conf"  
  
emc.tp1.df <- 
    merge(cca.emc, cca.emc.meta, by="ID") %>%
    .[,!(names(.) %in% drop)]
 
# SRT       
cca.srt <- 
  srt.parse[which(srt.parse$timepoint==1),]  %>%
  dplyr::rename(., "srt" = "sum.score") %>%
  .[,!(names(.) %in% drop)]

cca.srt.meta <- 
  srt.meta %>%
  na.omit(.) %>%
  dplyr::rename(., "srt.conf" = "Response") #  colnames(cca.srt.meta)[colnames(cca.srt.meta)=="Response"] <- "srt.conf"       
  
srt.tp1.df <- 
    merge(cca.srt, cca.srt.meta, by="ID") %>%
    .[,!(names(.) %in% drop)]

# CRT
cca.crt <- 
  crt.parse[which(crt.parse$timepoint==1),] %>%
  dplyr::rename(., "crt" = "sum.score") %>%
  .[,!(names(.) %in% drop)]

cca.crt.meta <- 
  crt.meta %>%
  na.omit(.) %>%
  dplyr::rename(., "crt.conf" = "Response") #  colnames(cca.srt.meta)[colnames(cca.srt.meta)=="Response"] <- "srt.conf"       
  
crt.tp1.df <- 
    merge(cca.crt, cca.crt.meta, by="ID") %>%
    .[,!(names(.) %in% drop)]      
        
# Trails     
cca.trails <- 
  trails.parse[which(trails.parse$timepoint==1),] %>%
  dplyr::rename(., "trailCost" = "sum.score") %>% #     colnames(cca.trails)[colnames(cca.trails)=="sum.score"] <- "trailCost"
  .[,!(names(.) %in% drop)] # cca.trails <- cca.trails[,!(names(cca.trails) %in% drop)]

cca.trails.meta <- 
  trails.meta %>%
  na.omit(.) %>%
  dplyr::rename(., "trail.conf" = "Response")  #    

trails.tp1.df <- 
    merge(cca.trails, cca.trails.meta, by="ID") %>%
    .[,!(names(.) %in% drop)]   

# PAL
cca.pal <- 
  pal.parse[which(pal.parse$timepoint==1),] %>%
  dplyr::rename(., "pal" = "sum.score") %>% 
  .[,!(names(.) %in% drop)] 

cca.pal.meta <- 
  pal.meta %>%
  na.omit(.) %>%
  dplyr::rename(., "pal.conf" = "Response")  #    

pal.tp1.df <- 
    merge(cca.pal, cca.pal.meta, by="ID") %>%
    .[,!(names(.) %in% drop)]   

# Target Detection        
cca.targetDetection <- 
  targetDetection.parse[which(targetDetection.parse$timepoint==1),] %>%
  dplyr::rename(., "targetDetection" = "sum.score") %>% 
  .[,!(names(.) %in% drop)] 

cca.targetDetection.meta <- 
  targetDetection.meta %>%
  na.omit(.) %>%
  dplyr::rename(., "targetDetection.conf" = "Response")  #    

targetDetection.tp1.df <- 
    merge(cca.targetDetection, cca.targetDetection.meta, by="ID") %>%
    .[,!(names(.) %in% drop)] 

 # Motor Control               
cca.motorControl <-  
  motorControl.parse [which(motorControl.parse $timepoint==1),] %>%
  dplyr::rename(., "motorControl" = "sum.score") %>% 
  .[,!(names(.) %in% drop)] 

cca.motorControl.meta <- 
  motorControl.meta %>%
  na.omit(.) %>%
  dplyr::rename(., "motorControl.conf" = "Response")  #    

motorControl.tp1.df <- 
    merge(cca.motorControl, cca.motorControl.meta, by="ID") %>%
    .[,!(names(.) %in% drop)] 
        
dropVars <- c("Group.y", "timepoint.x", "timepoint.y", "Group.x.x", "timepoint.x.x", "Group.y.y", "timepoint.y.y","Group.x.x.x", "timepoint.x.x.x", "Group.y.y.y", "timepoint.y.y.y","Group.x.x.x.x", "timepoint.x.x.x.x", "Group.y.y.y.y", "timepoint.y.y.y.y", "Date.x", "Date.x.x", "Date.x.x.x", "Date.x.x.x.x", "Date.y", "Date.y.y", "Date.y.y.y", "Date.y.y.y.y")

# Join for CAA behavioural dataframe              
 cca.behav.df <- 
   cca.emd %>% 
   inner_join(cca.emc, by = "ID") %>% 
   inner_join(cca.srt, by = "ID") %>% 
   inner_join(cca.crt, by = "ID") %>%
   inner_join(cca.trails, by = "ID") %>%
   inner_join(cca.pal, by = "ID") %>%
   inner_join(cca.targetDetection, by = "ID") %>%
   inner_join(cca.motorControl, by = "ID") %>%
   dplyr::rename(., "Group" = "Group.x") %>%
   .[,!(names(.) %in% dropVars)]

# Join for CAA metacognition dataframe              
 cca.metaCog.df <- 
   cca.emd.meta %>% 
   inner_join(cca.emc.meta, by = "ID") %>% 
   inner_join(cca.srt.meta, by = "ID") %>% 
   inner_join(cca.crt.meta, by = "ID") %>%
   inner_join(cca.trails.meta, by = "ID") %>%
   inner_join(cca.pal.meta, by = "ID") %>%
   inner_join(cca.targetDetection.meta, by = "ID") %>%
   inner_join(cca.motorControl.meta, by = "ID") %>%
   #rename(., "Group" = "Group.x") %>%
   .[,!(names(.) %in% dropVars)]
  
  cca.behav.df <- match_df(cca.behav.df, cca.metaCog.df, on = "ID")
 
        write.csv(cca.behav.df, file = "~/Google\ Drive/emo/cognitrack/taskRaw/cca.behav.df.csv", row.names=FALSE)
        write.csv(cca.metaCog.df, file = "~/Google\ Drive/emo/cognitrack/taskRaw/cca.metaCog.df.csv", row.names=FALSE)
                 
```


## Conversion of performance to POMP scores, creating a table of the difference betwene performance and confidence for PCA
```{r}
# POMS = [(observed − minimum)/(maximum − minimum)]
# POMP = 100*(raw - min)/(max - min)

# Emotional Discrimination
pomp.ED <- data.frame(ID=emd.tp1.df$ID, pomp.ed = double(length(emd.tp1.df$ID)))
n = length(emd.tp1.df$emd.total)
for (ii in 1:n) {
  pomp.ED$pomp.ed[ii] <- ((emd.tp1.df$emd.total[ii] - 0)/(50 - 0))*100
}

# Emotional Control
pomp.EC <- data.frame(ID=emc.tp1.df$ID, pomp.ec = double(length(emc.tp1.df$ID)))
n = length(emc.tp1.df$emc.total)
for (ii in 1:n) {
  pomp.EC$pomp.ec[ii] <- ((emc.tp1.df$emc.total[ii] - 0)/(50 - 0))*100
}

# PALS  
pomp.PAL <- data.frame(ID=pal.tp1.df$ID, pomp.pal = integer(length(pal.tp1.df$ID)))

n = length(pal.tp1.df$pal)
for (ii in 1:n) {
  pomp.PAL$pomp.pal[ii] <- round(((pal.tp1.df$pal[ii] - 0)/(max(pal.tp1.df$pal) - 0))*100)
}
  
# Motor control
pomp.mc <- data.frame(ID=motorControl.tp1.df$ID, pomp.mc = double(length(motorControl.tp1.df$ID)))
inv.mc <-(motorControl.tp1.df$motorControl)*-1

n = length(motorControl.tp1.df$ID)
for (ii in 1:n) {
  pomp.mc$pomp.mc[ii] <- round((inv.mc[ii] - min(inv.mc))/(max(inv.mc) - min(inv.mc))*100)
}

# SRT
pomp.srt <- data.frame(ID=srt.tp1.df$ID, pomp.srt = double(length(srt.tp1.df$ID)))
inv.srt <-(srt.tp1.df$srt)*-1

n = length(srt.tp1.df$ID)
for (ii in 1:n) {
  pomp.srt$pomp.srt[ii] <- round((inv.srt[ii] - min(inv.srt))/(max(inv.srt) - min(inv.srt))*100)
}

# CRT
crt.tp1.df <- crt.tp1.df[ which(crt.tp1.df$ID != "COAT0150"),]
crt.tp1.df$crt <- as.numeric(as.character(crt.tp1.df$crt))
pomp.crt <- data.frame(ID=crt.tp1.df$ID, pomp.crt = double(length(crt.tp1.df$ID)))
inv.crt <-(crt.tp1.df$crt)*-1

n = length(crt.tp1.df$ID)
for (ii in 1:n) {
  pomp.crt$pomp.crt[ii] <- round((inv.crt[ii] - min(inv.crt))/(max(inv.crt) - min(inv.crt))*100)
}

# Target Detection
pomp.targetDetection <- data.frame(ID=targetDetection.tp1.df$ID, pomp.td = double(length(targetDetection.tp1.df$ID)))

n = length(targetDetection.tp1.df$ID)
for (ii in 1:n) {
  pomp.targetDetection$pomp.td[ii] <- round((targetDetection.tp1.df$targetDetection[ii] - 0)/(max(targetDetection.tp1.df$targetDetection) - 0)*100)
}

# Trails
pomp.trails <- data.frame(ID=trails.tp1.df$ID, pomp.trails = double(length(trails.tp1.df$ID)))
inv.trails <-(trails.tp1.df$trailCost)*-1

n = length(trails.tp1.df$ID)
for (ii in 1:n) {
  pomp.trails$pomp.trails[ii] <- round((inv.trails[ii] - min(inv.trails))/(max(inv.trails) - min(inv.trails))*100)
}

# Merging this mother fucker 
pomp <- merge(pomp.mc, pomp.srt, all = TRUE)
#pomp <- merge(pomp, pomp.srt, all = TRUE)
pomp <- merge(pomp, pomp.crt, all = TRUE)
pomp <- merge(pomp, pomp.targetDetection, all = TRUE)
pomp <- merge(pomp, pomp.PAL, all = TRUE)
pomp <- merge(pomp, pomp.trails, all = TRUE)
pomp <- merge(pomp, pomp.ED, all = TRUE)
pomp <- merge(pomp, pomp.EC, all = TRUE)

write.csv(pomp, file = "~/pomp.csv", row.names=FALSE)
  pomp.na <- na.omit(pomp)
 
## Arrange confidence data to match number of observations, so can merge

mc <- data.frame(ID=motorControl.tp1.df$ID, mc = motorControl.tp1.df$motorControl.conf)
srt <- data.frame(ID=srt.tp1.df$ID, srt = srt.tp1.df$srt.conf)
crt <- data.frame(ID=crt.tp1.df$ID, crt = crt.tp1.df$crt.conf)
td <- data.frame(ID=targetDetection.tp1.df$ID, td = targetDetection.tp1.df$targetDetection.conf)
pal <- data.frame(ID=pal.tp1.df$ID, pal = pal.tp1.df$pal.conf)
trails <- data.frame(ID=trails.tp1.df$ID, trails = trails.tp1.df$trail.conf)
ed <- data.frame(ID=emd.tp1.df$ID, ed = emd.tp1.df$emd.conf)
ec <- data.frame(ID=emc.tp1.df$ID, ec = emc.tp1.df$emc.conf)


conf.df <- data.frame(ID=pomp$ID)
conf.df <- merge(conf.df, mc, all = TRUE)
conf.df <- merge(conf.df, srt, all = TRUE)
conf.df <- merge(conf.df, crt, all = TRUE)
conf.df <- merge(conf.df, td, all = TRUE)
conf.df <- merge(conf.df, pal, all = TRUE)
conf.df <- merge(conf.df, trails, all = TRUE)
conf.df <- merge(conf.df, ed, all = TRUE)
conf.df <- merge(conf.df, ec, all = TRUE)

mc.g <- data.frame(ID=motorControl.tp1.df$ID,  Group = motorControl.tp1.df$Group)
srt.g <- data.frame(ID=srt.tp1.df$ID, Group = srt.tp1.df$Group)
crt.g <- data.frame(ID=crt.tp1.df$ID, Group = crt.tp1.df$Group)
td.g <- data.frame(ID=targetDetection.tp1.df$ID,  Group = targetDetection.tp1.df$Group)
pal.g <- data.frame(ID=pal.tp1.df$ID,  Group = pal.tp1.df$Group)
trails.g <- data.frame(ID=trails.tp1.df$ID, Group = trails.tp1.df$Group)
ed.g <- data.frame(ID=emd.tp1.df$ID,  Group = emd.tp1.df$Group)
ec.g <- data.frame(ID=emc.tp1.df$ID,  Group = emc.tp1.df$Group)

g.df <- data.frame(ID=pomp$ID)
g.df <- merge(g.df, mc.g, all = TRUE)
g.df <- merge(g.df, srt.g, all = TRUE)
g.df <- merge(g.df, crt.g, all = TRUE)
g.df <- merge(g.df, td.g, all = TRUE)
g.df <- merge(g.df, pal.g, all = TRUE)
g.df <- merge(g.df, trails.g, all = TRUE)
g.df <- merge(g.df, ed.g, all = TRUE)
g.df <- merge(g.df, ec.g, all = TRUE)

gdf <- na.omit(g.df)

# Make meta accuracy (difference between performance and confidence) 
metaAccuracy.df <- data.frame(ID=pomp$ID, diff.mc = double(length(pomp$ID)), diff.srt = double(length(pomp$ID)), diff.crt = double(length(pomp$ID)),  diff.td = double(length(pomp$ID)), diff.pal = double(length(pomp$ID)), diff.trails = double(length(pomp$ID)), diff.ed = double(length(pomp$ID)), diff.ec = double(length(pomp$ID)))

metaAccuracy.df$diff.mc <- conf.df$mc - pomp$pomp.mc
metaAccuracy.df$diff.srt <-  conf.df$srt - pomp$pomp.srt
metaAccuracy.df$diff.crt <-  conf.df$crt - pomp$pomp.crt
metaAccuracy.df$diff.td <- conf.df$td - pomp$pomp.td 
metaAccuracy.df$diff.pal <- conf.df$pal - pomp$pomp.pal 
metaAccuracy.df$diff.trails <- conf.df$trails - pomp$pomp.srt 
metaAccuracy.df$diff.ed <- conf.df$ed - pomp$pomp.ed  
metaAccuracy.df$diff.ec <- conf.df$ec - pomp$pomp.ec 

write.csv(metaAccuracy.df, file = "~/metaAccuracy.csv", row.names=FALSE)

metaAcc.p <- metaAccuracy.df
metaAcc.p$group <- gdf$Group

```


# Analysis

## POMP
```{r}

df <- pomp %>%
  gather(key = "domain", value = "metacognition", pomp.mc:pomp.srt:pomp.crt:pomp.td:pomp.pal:pomp.trails:pomp.ed:pomp.ec) %>%   # long format 
  mutate(domain = factor(domain))      

 df$domain <- factor(df$domain ,levels = c("pomp.mc", "pomp.srt", "pomp.crt", "pomp.td", "pomp.pal", "pomp.trails", "pomp.ed", "pomp.ec"))
 
 df$group <- metaAcc.p$group

p1 <- ggplot(data = df, aes(x = domain, y = metacognition, colour = group)) +
        geom_boxplot(outlier.shape = NA) +
        stat_compare_means(label = "p.signif", size = 6) +
        #geom_hline(yintercept = mean(na.omit(df$metacognition)), linetype = 3) +
        #geom_hline(yintercept = mean(na.omit(df$metacognition[df$group == "TBI"])), linetype = 3, color = "#E64B35FF") +
        #geom_hline(yintercept = mean(na.omit(df$metacognition[df$group == "CON"])), linetype = 4, color = "#4DBBD5FF") +
        geom_point(size = pointSize, alpha = 0.7, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.02, dodge.width = 0.75, seed = NA)) +
        scale_x_discrete(labels=c("pomp.mc" = "MC", "pomp.srt" = "SRT", "pomp.crt" = "CRT", "pomp.td" = "Target detect", "pomp.pal" = "PAL", "pomp.trails" = "Trails", "pomp.ed" = "Emo disc.",  "pomp.ec" = "Emo control")) +
        theme(text = facetText, legend.text = facetText) +
        scale_color_manual(values = npgGroupPalette) +
        labs(title = "Task performance", x = "Task", y = "Percentage of maximum posible (POMP)", color = "Group") 
ggdraw(p1)

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/pomp.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/metacognitiveAccuracy.png", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

```
### Stats for pomp
```{r}

# # Do some stats
m1 <- lm(metacognition ~ domain*group, data = df) # *mCog*
Anova(m1, type="III")
summary(m1)
lsm = lsmeans(m1, ~group|domain) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")
 

# # Do some stats
m2 <- lmer(metacognition ~ domain*group + (1|ID), data = df) # *mCog*
Anova(m1, type="III")
# #summary(m1)
lsm = lsmeans(m1, ~group|domain) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")


```


## Confidence Judgement
```{r}

df <- conf.df %>%
  gather(key = "domain", value = "metacognition", mc:srt:crt:td:pal:trails:ed:ec) %>%   # long format 
  mutate(domain = factor(domain))      

 df$domain <- factor(df$domain ,levels = c("mc", ".srt", "crt", "td", "pal", "trails", "ed", "ec"))
 
 df$group <- metaAcc.p$group
df <- na.omit(df)
p1 <- ggplot(data = df, aes(x = domain, y = metacognition, colour = group)) +
        geom_boxplot(outlier.shape = NA) +
        stat_compare_means(label = "p.signif", size = 6) +
        #geom_hline(yintercept = mean(na.omit(df$metacognition)), linetype = 3) +
        #geom_hline(yintercept = mean(na.omit(df$metacognition[df$group == "TBI"])), linetype = 3, color = "#E64B35FF") +
        #geom_hline(yintercept = mean(na.omit(df$metacognition[df$group == "CON"])), linetype = 4, color = "#4DBBD5FF") +
        geom_point(size = pointSize, alpha = 0.7, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.02, dodge.width = 0.75, seed = NA)) +
        scale_x_discrete(labels=c("mc" = "MC", "srt" = "SRT", "crt" = "CRT", "td" = "Target detect", "pal" = "PAL", "trails" = "Trails", "ed" = "Emo disc.",  "ec" = "Emo control")) +
        theme(text = facetText, legend.text = facetText) +
        scale_color_manual(values = npgGroupPalette) +
        labs(title = "Confidence in task performance", x = "Task", y = "Confidence Judgement (CJ)", color = "Group") 
ggdraw(p1)

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/CJ.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/metacognitiveAccuracy.png", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

```
### Stats for confidence judgement
```{r}

# # Do some stats
m1 <- lm(metacognition ~ domain*group, data = df) # *mCog*
Anova(m1, type="III")
summary(m1)
lsm = lsmeans(m1, ~group|domain) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")
 

# # Do some stats
m2 <- lmer(metacognition ~ domain*group + (1|ID), data = df) # *mCog*
Anova(m1, type="III")
# #summary(m1)
lsm = lsmeans(m1, ~group|domain) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")


```


## Metacognitive Insight
```{r}

df <- metaAcc.p %>%
  gather(key = "domain", value = "metacognition", diff.mc:diff.srt:diff.crt:diff.td:diff.pal:diff.trails:diff.ed:diff.ec) %>%   # long format 
  mutate(domain = factor(domain))      

 df$domain <- factor(df$domain ,levels = c("diff.mc", "diff.srt", "diff.crt", "diff.td", "diff.pal", "diff.trails", "diff.ed", "diff.ec"))

p1 <- ggplot(data = df, aes(x = domain, y = metacognition, colour = group)) +
        geom_boxplot(outlier.shape = NA) +
        stat_compare_means(label = "p.signif", size = 6) +
        #geom_hline(yintercept = mean(na.omit(df$metacognition)), linetype = 3) +
        geom_hline(yintercept = mean(na.omit(df$metacognition[df$group == "TBI"])), linetype = 3, color = "#E64B35FF") +
        geom_hline(yintercept = mean(na.omit(df$metacognition[df$group == "CON"])), linetype = 4, color = "#4DBBD5FF") +
        geom_point(size = pointSize, alpha = 0.7, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.02, dodge.width = 0.75, seed = NA)) +
        scale_x_discrete(labels=c("diff.mc" = "MC", "diff.srt" = "SRT", "diff.crt" = "CRT", "diff.td" = "Target detect", "diff.pal" = "PAL", "diff.trails" = "Trails", "diff.ed" = "Emo disc.",  "diff.ec" = "Emo control")) +
        theme(text = facetText, legend.text = facetText) +
        scale_color_manual(values = npgGroupPalette) +
        labs(title = "Relative metacognitive accuracy", x = "Domain", y = "metacognitive insight (confidence - performance)", color = "Group") 
ggdraw(p1)

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/metacognitiveAccuracy.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/metacognitiveAccuracy.png", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

```

### Stats for metacogntive bias
```{r}

# # Do some stats
m1 <- lm(metacognition ~ domain*group, data = df) # *mCog*
Anova(m1, type="III")
summary(m1)
lsm = lsmeans(m1, ~group|domain) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")
 

# # Do some stats
m2 <- lmer(metacognition ~ domain*group + (1|ID), data = df) # *mCog*
Anova(m1, type="III")
# #summary(m1)
lsm = lsmeans(m1, ~group|domain) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")


```

## Metacognitive accuracy 

motorControl.tp1.df
srt.tp1.df
crt.tp1.df
targetDetection.tp1.df
trails.tp1.df
pal.tp1.df
emd.tp1.df
emc.tp1.df

```{r}

# Linear model prediciting confidence by performance and group
m1 <- lm(motorControl.conf ~ motorControl*Group, data = motorControl.tp1.df)
# get results of model
#summary(m2) 
Anova(m1, type="III")
# compare if slopes are different between groups (interaction)
lsm = lsmeans(m1, ~Group) # 
contrast(lsm, interaction = "pairwise", adjust="tukey")
# test if slopes are different to 0 for each group (does CI cross 0)
emtrends(m1, ~ Group, var = "motorControl")

# SRT
m2 <- lm(srt.conf ~ srt*Group, data = srt.tp1.df)
Anova(m2, type="III")
lsm = lsmeans(m2, ~Group)
contrast(lsm, interaction = "pairwise", adjust="tukey")
emtrends(m2, ~ Group, var = "srt") 

# CRT
m3 <- lm(crt.conf ~ crt*Group, data = crt.tp1.df)
Anova(m3, type="III")
lsm = lsmeans(m3, ~Group)
contrast(lsm, interaction = "pairwise", adjust="tukey")
emtrends(m3, ~ Group, var = "crt") 

# targetDetection.tp1.df
m4 <- lm(targetDetection.conf ~ targetDetection*Group, data = targetDetection.tp1.df)
Anova(m4, type="III")
lsm = lsmeans(m4, ~Group)
contrast(lsm, interaction = "pairwise", adjust="tukey")
emtrends(m4, ~ Group, var = "targetDetection") 


# trails.tp1.df
m5 <- lm(trail.conf ~ trailCost*Group, data = trails.tp1.df)
Anova(m5, type="II")
lsm = lsmeans(m5, ~Group)
contrast(lsm, interaction = "pairwise", adjust="tukey")
emtrends(m5, ~ Group, var = "trailCost") 

# pal.tp1.df
m6 <- lm(pal.conf ~ pal*Group, data = pal.tp1.df)
Anova(m6, type="III")
lsm = lsmeans(m6, ~Group)
contrast(lsm, interaction = "pairwise", adjust="tukey")
emtrends(m6, ~ Group, var = "pal") 

# emd.tp1.df
m7 <- lm(emd.conf ~ emd.total*Group, data = emd.tp1.df)
Anova(m7, type="II")
lsm = lsmeans(m7, ~Group)
contrast(lsm, interaction = "pairwise", adjust="tukey")
emtrends(m7, ~ Group, var = "emd.total") 

# emc.tp1.df
m8 <- lm(emc.conf ~ emc.total*Group, data = emc.tp1.df)
Anova(m8, type="II")
lsm = lsmeans(m8, ~Group)
contrast(lsm, interaction = "pairwise", adjust="tukey")
emtrends(m8, ~ Group, var = "emc.total") 

```


# Prospectivie performance (PMHQ)
Pass parsed questionnaire data from PMHQ into envirnment
```{r}
pmhq <- 
  read.csv("~/Google\ Drive/Imperial/emo/cognitrack/cleaned_PMH.csv") %>%
  #dplyr::rename(., "timepoint" = "timpoint") %>%
  dplyr::rename(., "Group" = "Group.x") %>%
  dplyr::rename(., "ID" = "Username.String.x")
  
pmhq.tp1 <- pmhq[which(pmhq$timepoint==1),]
prospective.mem <- merge(pmhq.tp1, pal.tp1.df, by = "ID")
prospective.att <- merge(pmhq.tp1, targetDetection.tp1.df, by = "ID")


```

# Prospective judgments
```{r}

n = length(prospective.mem$pal)
for (ii in 1:n) {
  prospective.mem$pomp.pal[ii] <- round(((prospective.mem$pal[ii] - 0)/(max(prospective.mem$pal) - 0))*100)
  prospective.mem$prospective_diff[ii] <-  (prospective.mem$pmh.memory[ii] - prospective.mem$pomp.pal[ii])
  prospective.mem$retro_diff[ii] <-  (prospective.mem$pal.conf[ii] - prospective.mem$pomp.pal[ii])
  prospective.mem$delta[ii] <-  (prospective.mem$pmh.memory[ii] - prospective.mem$pal.conf[ii])
}


# REMOVED AS PROSPECTIVE AND RETROSPECITVE NOT A FAIR DIRECT COMPARISON, SINCE PROSPECTIVE IS NOT LOCKED TO TASK

# df.pj <- prospective.mem %>%
#   dplyr::select(ID, Group.y, pomp.pal, pmh.memory, pal.conf)  %>% 
#   gather(key = "met", value = "k", pmh.memory:pal.conf)       %>%   # long format 
#   mutate(met = factor(met))                                   %>%   # factorise agent
#   mutate(ID = factor(ID))   
# 
# #relevel(df.pj$met, "pmh.memory")
# df.pj$met <- factor(df.pj$met, levels = c("pmh.memory","pal.conf"))
# 
# 
# p2 <- ggplot(df.pj, aes(x = k, y = pomp.pal, colour = met, shape = Group.y)) + 
#   facet_grid(. ~ Group.y) +
#   geom_smooth(method = "lm") +
#   geom_point(alpha = 0.7, size = 2) +
#   #geom_point(alpha = 0.7, size = 2, position = position_jitterdodge(jitter.width = 1.2, jitter.height = 2, dodge.width = 0.5, seed = NA)) +
#   xlab("Metacognitive judgement") +
#   ylab("Memory performance") +
#   scale_color_d3()  +
#   theme(text = textOption, plot.title = element_text(hjust = 0.5))
# p2
# 
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/pros-retro_memory.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)


 df.pj <- prospective.mem %>%
  dplyr::select(ID, Group.y, pomp.pal, pmh.memory, pal.conf)  %>%
  gather(key = "met", value = "k", pmh.memory:pal.conf)       %>%   # long format
  mutate(met = factor(met))                                   %>%   # factorise agent
  mutate(ID = factor(ID))

#relevel(df.pj$met, "pmh.memory")
df.pj$met <- factor(df.pj$met, levels = c("pmh.memory","pal.conf"))


p1 <- ggplot(prospective.mem, aes(x = pal.conf, y = pomp.pal, colour = Group.y, shape = Group.y)) +
  geom_smooth(method = "lm") +
  stat_cor(size = 5) +
  geom_point(alpha = 0.7, size = 2) +
  xlab("Judgement of memory function") +
  ylab("Memory performance") +
  scale_color_manual(values = npgGroupPalette) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p1

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/prospective-memory.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)





 df.pj <- prospective.mem %>%
  dplyr::select(ID, Group.y, pomp.pal, pmh.memory, pal.conf)  %>%
  gather(key = "met", value = "k", pmh.memory:pal.conf)       %>%   # long format
  mutate(met = factor(met))                                   %>%   # factorise agent
  mutate(ID = factor(ID))
   
   
p1 <- ggplot(df.pj, aes(x = met, y = k, colour = Group.y)) +
  geom_boxplot(outlier.shape = NA) +
  geom_point(size = pointSize, alpha = 0.7, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.02, dodge.width = 0.75, seed = NA))  +
  xlab("Group") +
  ylab("Judgements of memory") +
  scale_color_manual(values = npgGroupPalette) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p1



```

## Attention
```{r}

n = length(prospective.att$targetDetection)
for (ii in 1:n) {
  prospective.att$pomp.targetDetection[ii] <- round(((prospective.att$targetDetection[ii] - 0)/(max(prospective.att$targetDetection) - 0))*100)
  prospective.att$prospective_diff[ii] <-  (prospective.att$pmh.concentration[ii] - prospective.att$targetDetection[ii])
  prospective.att$retro_diff[ii] <-  (prospective.att$targetDetection.conf[ii] - prospective.att$pomp.targetDetection[ii])
  prospective.att$delta[ii] <-  (prospective.att$pmh.concentration[ii] - prospective.att$targetDetection.conf[ii])
}

df.pj <- prospective.att %>%
  dplyr::select(ID, Group.y, pomp.targetDetection, pmh.concentration, targetDetection.conf)  %>%
  gather(key = "met", value = "k",  pmh.concentration:targetDetection.conf)       %>%   # long format
  mutate(met = factor(met))                                   %>%   # factorise agent
  mutate(ID = factor(ID))
# 
# 
# p2 <- ggplot(df.pj, aes(x = k, y = pomp.targetDetection, colour = met, shape = Group.y)) + 
#   facet_grid(. ~ Group.y) +
#   geom_smooth(method = "lm") + stat_cor(method = "spearman", size = 6) +
#   geom_point(alpha = 0.7, size = 2, position = position_jitterdodge(jitter.width = 1.2, jitter.height = 2, dodge.width = 0.5, seed = NA)) +
#   xlab("Metacognitive judgement") +
#   ylab("Attention performance") +
#   scale_color_d3()  +
#   theme(text = textOption, plot.title = element_text(hjust = 0.5))
# p2

#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/pros-retro_attention.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)

p2 <- ggplot(prospective.att, aes(x = targetDetection.conf, y = targetDetection, colour = Group.y, shape = Group.y)) +
  geom_smooth(method = "lm") +
  stat_cor(size = 5) +
  geom_point(alpha = 0.7, size = 2) +
  xlab("Judgement of attention function") +
  ylab("Attentional performance") +
  scale_color_manual(values = npgGroupPalette) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p2

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/prospective-attention.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)






p2 <- ggplot(df.pj, aes(x = met, y = k, colour = Group.y)) +
  geom_boxplot(outlier.shape = NA) +
  geom_point(size = pointSize, alpha = 0.7, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.02, dodge.width = 0.75, seed = NA))  +
  xlab("Group") +
  ylab("Judgements of attention") +
  scale_color_manual(values = npgGroupPalette) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p2


fPlot <- ggarrange(
         p1, 
         p2, 
         nrow = 1, ncol = 2,
         common.legend = TRUE,
         legend = "right")
fPlot
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/prospective-judgement.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)



```

# DELTA
```{r}

# Mood & Memory
p1 <- ggplot(prospective.mem, aes(x = pmh.sad, y = delta, colour = Group.y, shape = Group.y)) + 
  #facet_grid(. ~ Group.y) +
  geom_smooth(method = "lm") +
  geom_point(alpha = 0.7, size = 2) +
  #geom_point(alpha = 0.7, size = 2, position = position_jitterdodge(jitter.width = 1.2, jitter.height = 2, dodge.width = 0.5, seed = NA)) +
  xlab("Self-report mood") +
  ylab("ΔMemory judgement") +
  #scale_color_d3()  +
  scale_color_manual(values = npgGroupPalette) +
  stat_cor(show.legend = FALSE, size = 5) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p1

# Linear model predicic confidence by performance and group
m1 <- lm(delta ~ pmh.sad*Group.y, data = prospective.mem)
Anova(m1, type="II")

# Anxiety & Attention
p2 <- ggplot(prospective.mem, aes(x = pmh.anxious, y = delta, colour = Group.y, shape = Group.y)) + 
  #facet_grid(. ~ Group.y) +
  geom_smooth(method = "lm") +
  geom_point(alpha = 0.7, size = 2) +
  #geom_point(alpha = 0.7, size = 2, position = position_jitterdodge(jitter.width = 1.2, jitter.height = 2, dodge.width = 0.5, seed = NA)) +
  xlab("Self-report anxiety") +
  ylab("ΔMemory judgement") +
  #scale_color_d3()  +
  scale_color_manual(values = npgGroupPalette) +
  stat_cor(show.legend = FALSE, size = 5) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p2

# Linear model predicic confidence by performance and group
m2 <- lm(delta ~ pmh.anxious*Group.y, data = prospective.mem)
Anova(m2, type="II")

# Mood & Attention
p3 <- ggplot(prospective.att, aes(x = pmh.sad, y = delta, colour = Group.y, shape = Group.y)) + 
  #facet_grid(. ~ Group.y) +
  geom_smooth(method = "lm") +
  geom_point(alpha = 0.7, size = 2) +
  #geom_point(alpha = 0.7, size = 2, position = position_jitterdodge(jitter.width = 1.2, jitter.height = 2, dodge.width = 0.5, seed = NA)) +
  xlab("Self-report mood") +
  ylab("ΔAttention judgement") +
  #scale_color_d3()  +
  scale_color_manual(values = npgGroupPalette) +
  stat_cor(show.legend = FALSE, size = 5) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p3

# Linear model predicic confidence by performance and group
m3 <- lm(delta ~ pmh.sad*Group.y, data = prospective.att)
Anova(m3, type="II")

# Anxiety & Attention
p4 <- ggplot(prospective.att, aes(x = pmh.anxious, y = delta, colour = Group.y, shape = Group.y)) + 
  #facet_grid(. ~ Group.y) +
  geom_smooth(method = "lm") +
  geom_point(alpha = 0.7, size = 2) +
  #geom_point(alpha = 0.7, size = 2, position = position_jitterdodge(jitter.width = 1.2, jitter.height = 2, dodge.width = 0.5, seed = NA)) +
  xlab("Self-report anxiety") +
  ylab("ΔAttention judgement") +
  #scale_color_d3()  +
  scale_color_manual(values = npgGroupPalette) +
  stat_cor(show.legend = FALSE, size = 5) +
  theme(text = textOption, plot.title = element_text(hjust = 0.5))
p4

# Linear model predicic confidence by performance and group
m4 <- lm(delta ~ pmh.anxious*Group.y, data = prospective.att)
Anova(m4, type="II")


fPlot <- ggarrange(
         p1, 
         p2, 
         p3,
         p4,
         nrow = 2, ncol = 2,
         common.legend = TRUE,
         legend = "right")
fPlot

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/delta.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)


tmp1 <- prospective.att
names(tmp1)[names(tmp1) == "delta"] <- "delta.att"
tmp2 <- prospective.mem
names(tmp2)[names(tmp2) == "delta"] <- "delta.mem"

pro.df <- merge(tmp1, tmp2, by = "ID")
names(pro.df)[names(pro.df) == "Group.x.x"] <- "Group"
#names(pro.df)[names(pro.df) == "delta.x"] <- "delta"
names(pro.df)[names(pro.df) == "pmh.anxious.x"] <- "pmh.anxious"
names(pro.df)[names(pro.df) == "pmh.sad.x"] <- "pmh.sad"



df <- pro.df %>%
  dplyr::select(ID, Group, pmh.sad, pmh.anxious, delta.att, delta.mem)   %>%
  gather(key = "domain", value = "score", pmh.sad:pmh.anxious) %>%   # long format 
  mutate(domain = factor(domain))  %>%
  gather(key = "delta", value = "val", delta.att:delta.mem) %>%   # long format 
  mutate(delta = factor(delta))  

m <- lm(val ~ score*domain*Group*delta, data = df)
Anova(m, type = "II")

```

# Analysis of metacognitive insight & mood
```{r}

df.w <- merge(metaAcc.p, pmhq.tp1, by = "ID")
 
n = length(df.w$ID)
for (ii in 1:n) {
  #mat <- df.w[c(2:9)]
  vec <- t(df.w[ii, 2:9])#(df.w$diff.mc[ii], df.w$diff.srt[ii], df.w$diff.crt[ii], df.w$diff.td[ii], df.w$diff.pal[ii], df.w$diff.trails[ii],  df.w$diff.ed[ii], df.w$diff.ec[ii])
df.w$avg[ii] <- mean(vec, na.rm=TRUE)
}
  

p1 <- ggplot(df.w, aes(x = pmh.sad, y = avg, color = group)) +
  geom_smooth(method = "lm") +
  geom_point(alpha = 0.7, size = 2) +
  stat_cor(size = 6, show.legend = FALSE) +
  xlab("Mood: Sad - Happy") +
  ylab("Metacognitive insight") +
  labs(color = "Group") +
  scale_color_manual(values = npgGroupPalette) +
  theme(text = textOption, legend.text = textOption)

ggdraw(p1)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/insight-mood.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

m1 <- lm(avg ~ group*pmh.sad, data = df.w)
#summary(m1) 
Anova(m1, type = "II")
# lsm = lsmeans(m1, ~group)
# contrast(lsm, interaction = "pairwise", adjust="tukey")


p2 <- ggplot(df.w, aes(x = pmh.anxious, y = avg, color = group)) +
  geom_smooth(method = "lm") +
  geom_point(alpha = 0.7, size = 2) +
  stat_cor(size = 6, show.legend = FALSE) +
  xlab("Anxiety: High - low") +
  ylab("Metacognitive insight") +
  labs(color = "Group") +
  scale_color_manual(values = npgGroupPalette) +
  theme(text = textOption, legend.text = textOption)

ggdraw(p2)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/insight-anxiety.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

m2 <- lm(avg ~ group*pmh.anxious, data = df.w)
#summary(m1) 
Anova(m2, type = "II")
lsm = lsmeans(m2, ~group)
contrast(lsm, interaction = "pairwise", adjust="tukey")

fPlot <- ggarrange(
         p1, 
         p2, 
         nrow = 1, ncol = 2,
         common.legend = TRUE,
         legend = "right")
fPlot
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/insight-wellbeing.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)

```
There was no interaction between group and mood on metacognitive insight. However main effects of mood was seen


## factor scores from two factor PCA solution for descrepencay in metacogntion
```{r}
# factor scores from two factor PCA solution for descrepencay in metacogntion
fs <- read.csv("~/Google\ Drive/Imperial/PhD/Thesis/analysis/matlab_metacog/df/arc/factorScores.csv")

t.test(fs$b1 ~ metaAcc.p$group)
t.test(fs$b2 ~ metaAcc.p$group)
describeBy(fs$b1,  metaAcc.p$group)

qt <- quantile(fs$b1)

# CRT & F1
p1 <-  ggplot(data = fs, aes(x = pomp$pomp.crt, y = b1, colour = metaAcc.p$group)) +
        geom_smooth(method = lm, size = 1) +
        geom_jitter(size = pointSize) +
        stat_cor(method = "spearman", size = 6) +
        ggtitle("Score & metacognitive bias") +
        xlab("CRT Performance") +
        ylab("F1 betas") +
        labs(colour = "Group") +
        geom_hline(yintercept = qt[3], linetype = 3) +
        geom_vline(xintercept = 50, linetype = 3) +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText) 
        #stat_ellipse()
ggdraw(p1)

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/F1_CRT.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)


# Do some stats
m2 <- lm(fs$b1 ~ pomp$pomp.crt*metaAcc.p$group, data = metaAcc.p) # *mCog*
Anova(m2, type="II")
# #summary(m1)
lsm = lsmeans(m2, ~group) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")
# test if slopes are different to 0 for each group (does CI cross 0)
# emtrends(m2, ~ group, var = "fs$b1") 


# SCT and F1
p2 <-  ggplot(data = fs, aes(x = pomp$pomp.srt, y = b1, colour = metaAcc.p$group)) +
        geom_smooth(method = lm, size = 1) +
        geom_jitter(size = pointSize) +
        stat_cor(method = "spearman", size = 6) +
        ggtitle("Score & metacognitive bias") +
        xlab("SRT Performance") +
        ylab("F1 betas") +
        labs(colour = "Group") +
        geom_hline(yintercept = qt[3], linetype = 3) +
        geom_vline(xintercept = 50, linetype = 3) +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText) 
        #stat_ellipse()
ggdraw(p2)

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/F1_SRT.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)


# Do some stats
m2 <- lm(fs$b1 ~ pomp$pomp.srt*metaAcc.p$group, data = metaAcc.p) # *mCog*
Anova(m2, type="II")
# #summary(m1)
lsm = lsmeans(m2, ~group) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")
# test if slopes are different to 0 for each group (does CI cross 0)
# emtrends(m2, ~ group, var = "fs$b1") 

# Motor control & F1
p3 <-  ggplot(data = fs, aes(x = pomp$pomp.mc, y = b1, colour = metaAcc.p$group)) +
        geom_smooth(method = lm, size = 1) +
        geom_jitter(size = pointSize) +
        stat_cor(method = "spearman", size = 6) +
        ggtitle("Score & metacognitive bias") +
        xlab("MC Performance") +
        ylab("F1 betas") +
        labs(colour = "Group") +
        geom_hline(yintercept = qt[3], linetype = 3) +
        geom_vline(xintercept = 50, linetype = 3) +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText) 
        #stat_ellipse()
ggdraw(p3)

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/F1_MC.pdf", plot = p3, width = 12, height = 8, units = c("in"), dpi = 300)


# Do some stats
m2 <- lm(fs$b1 ~ pomp$pomp.mc*metaAcc.p$group, data = metaAcc.p) # *mCog*
Anova(m2, type="II")
# #summary(m1)
lsm = lsmeans(m2, ~group) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")
# test if slopes are different to 0 for each group (does CI cross 0)
# emtrends(m2, ~ group, var = "fs$b1") 


# CRT & metacognitive bias
p4 <-  ggplot(data = fs, aes(x = pomp$pomp.crt, y = metaAcc.p$diff.crt, colour = metaAcc.p$group)) +
        geom_smooth(method = lm, size = 1) +
        geom_jitter(size = pointSize) +
        stat_cor(method = "spearman", size = 6) +
        ggtitle("Score & metacognitive bias") +
        xlab("CRT Performance") +
        ylab("metacognitive bias") +
        labs(colour = "Group") +
        geom_hline(yintercept = qt[3], linetype = 3) +
        geom_vline(xintercept = 50, linetype = 3) +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText) 
        #stat_ellipse()
ggdraw(p4)

```



--- BETA ---

## Emotional Discrimination
```{r}

df <- emd.tp1.df
# Specific measures for emotional tasks
df$costAcc = (df$emd.inCongAcc - df$emd.congAcc)
df$costRT = (df$emd.medianInCongRT - df$emd.medianCongRT)
df$emd.RT <- (df$emd.medianInCongRT + df$emd.medianCongRT)

# standard scores
df$z.total <- scale(df$emd.total)
df$z.costAcc <- scale(df$costAcc)
df$z.costRT <- scale(df$costRT)
df$z.pm <- scale(df$emd.conf)
# remove missing values
df <- na.omit(df)

df <- dplyr::rename(df, "V1" = "z.total")
df <- dplyr::rename(df, "pm" = "emd.conf")

    n = length(df$V1)
  
      for (i in 1:n) {
      # score cat
      if (df$V1[i] >= 1) {
        df$cat[i] <- "good"
      } else if (df$V1[i] <= -1) {
        df$cat[i] <- "bad"
      } else  {
        df$cat[i] <- "average"
      }
        
        # meta cat
      if (df$z.pm[i] >= 0.5) {
        df$mCat[i] <- "highConf"
      } else if (df$z.pm[i] <= 0.5) {
        df$mCat[i] <- "lowConf"
      }  else {
        df$mCat[i] <- "uncertain"
      }
        
      if (df$mCat[i] == "highConf" && df$cat[i] == "bad") {
          df$mCog[i] <- "impaired_lowInsight"
        } else if (df$mCat[i] == "lowConf" && df$cat[i] == "bad") {
          df$mCog[i] <- "impaird_goodInsight"
        } else if (df$mCat[i] == "highConf" && df$cat[i] == "good") {
          df$mCog[i] <- "high_goodInsight"
        } else if (df$mCat[i] == "lowConf" && df$cat[i] == "good") {
          df$mCog[i] <- "high_lowConf"
        } else if (df$mCat[i] == "highConf" && df$cat[i] == "average") {
          df$mCog[i] <- "average_highConf"
        } else if (df$mCat[i] == "lowConf" && df$cat[i] == "average") {
          df$mCog[i] <- "average_lowConf"
        } else if (df$mCat[i] == "uncertain" && df$cat[i] == "average") {
          df$mCog[i] <- "average_uncertain"
        } else if (df$mCat[i] == "uncertain" && df$cat[i] == "good") {
          df$mCog[i] <- "good_uncertain"
        } else if (df$mCat[i] == "uncertain" && df$cat[i] == "bad") {
          df$mCog[i] <- "bad_uncertain"
        } else {
          df$mCog[i] <- "unclasified"
        }
        
      }

# Run some plots 

p1 <-  ggplot(data = df, aes(x = df$Group, y = emd.total, colour = df$Group)) +
        geom_boxplot() +
        geom_jitter(size = fpSize) +
        stat_compare_means(label.x = 0.7, size = 5) +
        ggtitle("A) ED Performance") +
        xlab("Group") +
        ylab("Total score") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)
#ggdraw(p1)

p2 <-  ggplot(data = df, aes(x = df$Group, y = df$pm, colour = df$Group)) +
        geom_boxplot() +
        geom_jitter(size = fpSize) +
        stat_compare_means(label.x = 0.7, size = 5) +
        ggtitle("B) ED Performance judgment") +
        xlab("Group") +
        ylab("Confidence judgement") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)
#ggdraw(p2)

# costRT
p3 <-  ggplot(data = df, aes(x = df$Group, y = emd.RT, colour = df$Group)) + 
        geom_boxplot() +
        geom_jitter(size = fpSize) +
        stat_compare_means(label.x = 0.7, size = 5) +
        ggtitle("C) ED Reaction time") +
        xlab("Group") +
        ylab("Reaction time (ms)") + # cost
        ylim(2000,8000) +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)
#ggdraw(p3)

p4 <-  ggplot(data = df, aes(x = df$pm, y = df$emd.total, colour = df$Group)) +
        geom_smooth(method = lm) +
        geom_jitter(size = fpSize) +
        stat_cor(method = "spearman", size = 5) +
        ggtitle("C) Score & Performance judgment") +
        xlab("Performance judgement") +
        ylab("Total score") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)
#ggdraw(p4)

fPlot <- ggarrange(p1, 
          p2, 
          p3,
          p4,
          nrow = 2, ncol = 2)

ggdraw(fPlot)
# Needs illustrator editing
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/emotionalDiscriminationSummary2.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/emotionalDiscriminationSummary2.png", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)


# Plot of discrimination & confidence judgment
p5 <-  ggplot(data = df, aes(x = Group , y = emd.total, colour = mCat)) +
        geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        #geom_jitter(shape=1) +
        geom_boxplot(alpha = 0.7) +
        geom_hline(yintercept = median(df$emd.total), linetype = 2) + # Add horizontal line at base
        ggtitle("D) Emotional discrimination & confidence in performance") +
        xlab("Group") +
        ylab("Total score") +
        labs(colour = "Performance judgement") +
        colPalette
ggdraw(p5)

p6 <-  ggplot(data = df, aes(x = Group , y = costRT, colour = mCat)) +
        geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        #geom_jitter(shape=1) +
        geom_boxplot(alpha = 0.7) +
        geom_hline(yintercept = median(df$costRT), linetype = 2) + # Add horizontal line at base
        ggtitle("D) Emotional discrimination cost RT & confidence in performance") +
        xlab("Group") +
        ylab("Cost reaction time") +
        labs(colour = "Performance judgement") +
        colPalette
ggdraw(p6)


# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/ED_cost-meta.pdf", plot = p6, width = 12, height = 8, units = c("in"), dpi = 300)


# # Do some stats
m1 <- lm(emd.total ~ mCat*Group, data = df) # *mCog*
Anova(m1, type="II")
# #summary(m1)
lsm = lsmeans(m1, ~Group|mCat) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")
 
# # # Do some stats
# m2 <- lm(pm ~ emd.total*Group, data = df) # *mCog*
# Anova(m2, type="II")
# # #summary(m1)
# lsm = lsmeans(m2, ~Group) # mCog*
# contrast(lsm, interaction = "pairwise", adjust="tukey")


# Linear model predicic confidence by performance and group
m2 <- lm(pm ~ emd.total*Group, data = df)
# get results of model
summary(m2) 
# test if slopes are different to 0 for each group (does CI cross 0)
emtrends(m2, ~ Group, var = "emd.total") 
# compare if slopes are different between groups (interaction)
lsm = lsmeans(m2, ~Group) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")


Anova(m2, type="II")


```


## Emotional control
```{r}

df <- emc.tp1.df
# Specific measures for emotional tasks
df$costAcc <- (df$emc.inCongAcc - df$emc.congAcc)
df$costRT <- (df$emc.medianInCongRT - df$emc.medianCongRT)
# standard scores
df$z.total <- scale(df$emc.total)
df$z.costAcc <- scale(df$costAcc)
df$z.costRT <- scale(df$costRT)
df$z.pm <- scale(df$emc.conf)
# remove missing values
df <- na.omit(df)

df <- dplyr::rename(df, "V1" = "z.total")
df <- dplyr::rename(df, "pm" = "emc.conf")

    n = length(df$V1)
  
      for (i in 1:n) {
      # score cat
      if (df$V1[i] >= 1.0) {
        df$cat[i] <- "good"
      } else if (df$V1[i] <= -1.0) {
        df$cat[i] <- "bad"
      } else  {
        df$cat[i] <- "average"
      }
        
      # meta cat
      if (df$z.pm[i] >= 0.5) {
        df$mCat[i] <- "highConf"
      } else if (df$z.pm[i] <= -0.5) {
        df$mCat[i] <- "lowConf"
      }  else {
        df$mCat[i] <- "uncertain"
      }
        
        
      # # meta cat
      # if (df$pm[i] >= 60) {
      #   df$mCat[i] <- "highConf"
      # } else if (df$pm[i] <= 40) {
      #   df$mCat[i] <- "lowConf"
      # }  else {
      #   df$mCat[i] <- "uncertain"
      # }
        
      if (df$mCat[i] == "highConf" && df$cat[i] == "bad") {
        df$mCog[i] <- "impaired_lowInsight"
      } else if (df$mCat[i] == "lowConf" && df$cat[i] == "bad") {
        df$mCog[i] <- "impaird_goodInsight"
      } else if (df$mCat[i] == "highConf" && df$cat[i] == "good") {
        df$mCog[i] <- "high_goodInsight"
      } else if (df$mCat[i] == "lowConf" && df$cat[i] == "good") {
        df$mCog[i] <- "high_lowConf"
      } else if (df$mCat[i] == "highConf" && df$cat[i] == "average") {
        df$mCog[i] <- "average_highConf"
      } else if (df$mCat[i] == "lowConf" && df$cat[i] == "average") {
        df$mCog[i] <- "average_lowConf"
      } else if (df$mCat[i] == "uncertain" && df$cat[i] == "average") {
        df$mCog[i] <- "average_uncertain"
      } else if (df$mCat[i] == "uncertain" && df$cat[i] == "good") {
        df$mCog[i] <- "good_uncertain"
      } else if (df$mCat[i] == "uncertain" && df$cat[i] == "bad") {
        df$mCog[i] <- "bad_uncertain"
      } else {
        df$mCog[i] <- "unclasified"
      }
    }
    

# Run some plots 
p1 <-  ggplot(data = df, aes(x = df$Group, y = emc.total, colour = df$Group)) +
        geom_boxplot(alpha = 0.7, size = 1, outlier.shape = NA) +
        geom_jitter(size = pointSize) +
        stat_compare_means(label.x = 1.2, size = 6) +
        ggtitle("A) Emotional control") +
        xlab("Group") +
        ylab("Total score") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)
 
p2 <-  ggplot(data = df, aes(x = df$Group, y = df$pm, colour = df$Group)) +
        geom_boxplot(alpha = 0.7, size = 1, outlier.shape = NA) +
        geom_jitter(size = pointSize) +
        stat_compare_means(label.x = 1.2, size = 6) +
        ggtitle("B) EC CJ") +
        xlab("Group") +
        ylab("Confidence judgement") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)


p3 <-  ggplot(data = df, aes(x = df$Group, y = costRT, colour = df$Group)) +
        geom_boxplot(alpha = 0.7, size = 1, outlier.shape = NA) +
        geom_jitter(size = pointSize) +
        stat_compare_means(label.x = 1.2, size = 6) +
        ggtitle("C) EC reaction time cost") +
        xlab("Group") +
        ylab("Cost reaction time (ms)") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)

p4 <-  ggplot(data = df, aes(x = df$pm, y = df$emc.total, colour = df$Group)) +
        geom_smooth(method = lm, size = 1) +
        geom_jitter(size = pointSize) +
        stat_cor(method = "spearman", size = 6) +
        ggtitle("D) EC socre & CJ") +
        xlab("Confidence judgement") +
        ylab("Total score") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)

#ggdraw(p5)

fPlot <- ggarrange(p1, 
          p2, 
          p3,
          p4,
          nrow = 2, ncol = 2)

fPlot
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/emotionalControlSummary.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)



# Plot of emc & confidence judgment
p5 <-  ggplot(data = df, aes(x = Group , y = emc.total, colour = mCat)) +
        geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        #geom_jitter(shape=1) +
        geom_boxplot(alpha = 0.7) +
        geom_hline(yintercept = median(df$emc.total), linetype = 2) + # Add horizontal line at base
        ggtitle("D) Emotional control & confidence in performance") +
        xlab("Group") +
        ylab("Total score") +
        labs(colour = "Performance judgement") +
        colPalette

p6 <-  ggplot(data = df, aes(x = Group , y = costRT, colour = mCat)) +
        geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        #geom_jitter(shape=1) +
        geom_boxplot(alpha = 0.7) +
        geom_hline(yintercept = median(df$costRT), linetype = 2) + # Add horizontal line at base
        ggtitle("D) Emotional control cost RT & confidence in performance") +
        xlab("Group") +
        ylab("Cost reaction time") +
        labs(colour = "Performance judgement") +
        colPalette

#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/EC_cost-meta.pdf", plot = p6, width = 12, height = 8, units = c("in"), dpi = 300)


# # Do some stats
m1 <- lm(emc.total ~ mCat*Group, data = df) # *mCog*
Anova(m1, type="II")
# #summary(m1)
lsm = lsmeans(m1, ~Group|mCat) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

table(df$mCat, df$Group)
tmp.df <-  df[ which(df$mCat == "lowConf"), ]
describeBy(tmp.df$emc.total, tmp.df$Group)


# Linear model predicic confidence by performance and group
m2 <- lm(pm ~ emc.total*Group, data = df)
# get results of model
summary(m2) 
# test if slopes are different to 0 for each group (does CI cross 0)
emtrends(m2, ~ Group, var = "emc.total") 
# compare if slopes are different between groups (interaction)
lsm = lsmeans(m2, ~Group) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

Anova(m2, type="II")


```
 

# PAL
```{r}
ps <- scale(pal.tp1.df$pal)
p <- as.data.frame(ps)
p$pm <- pal.tp1.df$pal.conf
p$raw <- as.numeric(as.character(pal.tp1.df$pal))
p$z.total <- scale(p$raw) # standard scores
p$z.pm <- scale(p$pm)
p$g <- pal.tp1.df$Group
p <- na.omit(p)

    n = length(p$V1)
    for (i in 1:n) {
      p$V1[i] <- (p$V1[i]*-1)
    }
    
      for (i in 1:n) {
      # score cat
      if (p$V1[i] >= 1.0) {
        p$cat[i] <- "good"
      } else if (p$V1[i] <= -1.0) {
        p$cat[i] <- "bad"
      } else  {
        p$cat[i] <- "average"
      }
        
      # meta cat
      if (p$z.pm[i] >= 0.5) {
        p$mCat[i] <- "highConf"
      } else if (p$z.pm[i] <= -0.5) {
        p$mCat[i] <- "lowConf"
      }  else {
        p$mCat[i] <- "uncertain"
      }
        
      
      if (p$mCat[i] == "highConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "impaired_lowInsight"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "impaird_goodInsight"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "good") {
        p$mCog[i] <- "high_goodInsight"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "good") {
        p$mCog[i] <- "high_lowConf"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_lowConf"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "average") {
        p$mCog[i] <- "average_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "good") {
        p$mCog[i] <- "good_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_uncertain"
      } else {
        p$mCog[i] <- "unclasified"
      }
    }
    

p1 <-  ggplot(data = p, aes(x = g , y = raw, colour = mCat)) +
        geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_hline(yintercept = median(p$raw), linetype = 2) +  # Add horizontal line at base      
        ggtitle("D) Metacognition grouping") +
        xlab("Group") +
        ylab("PAL performance") +
        labs(colour = "Metacognition") +
        colPalette +
        theme(text = facetText, legend.text = facetText)

ggdraw(p1)  


# Summary plots 
# Load in data
df <- pal.tp1.df

# Run some plots 
p2 <-  ggplot(data = df, aes(x = df$Group, y = df$pal.conf, colour = df$Group)) +
        geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
        geom_jitter(size = pointSize) +
        stat_compare_means(label.x = 0.7, size = 6) +
        ggtitle("B) Confidence of PAL performance") +
        xlab("Group") +
        ylab("PAL confidence judgement") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)

ggdraw(p2)

p3 <-  ggplot(data = df, aes(x = df$Group, y = df$pal, colour = df$Group)) +
        geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
        geom_jitter(size = pointSize) +
        stat_compare_means(label.x = 0.7, size = 6) +
        ggtitle("A) PAL performance") +
        xlab("Group") +
        ylab("PAL score") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)

ggdraw(p3)

#df$pal.conf[df$pal.conf == 50] <- NA
p4 <-  ggplot(data = df, aes(x = df$pal.conf, y = df$pal, colour = df$Group)) +
        geom_jitter(size = pointSize) +
        geom_smooth(method = lm) +
        stat_cor(method = "spearman", size = 6) + #size = 12
        ggtitle("C) PAL & confidence in performance") +
        xlab("Confidence in performance") +
        ylab("PAL") +
        labs(colour = "Group") +
        #theme(plot.title = element_text(hjust = 0.5)) +  #text = textOption, axis.text=element_text(size = 12 , vjust=1, hjust=1.0),
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)

ggdraw(p4)

fPlot <- ggarrange(
         p3, 
         p2, 
         p4,
         p1,
         nrow = 2, ncol = 2)
fPlot

ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/palSummary.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)

# # Do some stats
m1 <- lm(raw ~ mCat*g, data = p) # *mCog*
Anova(m1, type="II")
# #summary(m1)
lsm = lsmeans(m1, ~g|mCat) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

df <-p
table(df$mCat, df$g)
# tmp.df <-  df[ which(df$mCat == "lowConf"), ]
# describeBy(tmp.df$raw, tmp.df$g)

tmp.df <-  df[ which(df$mCat == "highConf"), ]
describeBy(tmp.df$raw, tmp.df$g)

require("dplyr")
group_by(df, g, mCat) %>%
  summarise(
    count = n(),
    mean = mean(raw, na.rm = TRUE),
    sd = sd(raw, na.rm = TRUE)
  )

# Linear model predicic confidence by performance and group
m2 <- lm(pm ~ raw*g, data = p)
# get results of model
summary(m2) 
# test if slopes are different to 0 for each group (does CI cross 0)
emtrends(m2, ~ g, var = "raw") 
# compare if slopes are different between groups (interaction)
lsm = lsmeans(m2, ~g) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")


Anova(m2, type="II")





```
# Motor Control
```{r}

ps <- scale(as.numeric(as.character(motorControl.tp1.df$motorControl)))
rm(p)
p <- as.data.frame(ps)
p$pm <- motorControl.tp1.df$motorControl.conf
p$z.pm <- scale(p$pm)
p$raw <- as.numeric(as.character(motorControl.tp1.df$motorControl))
p$g <- motorControl.tp1.df$Group
p <- na.omit(p)

    n = length(p$V1)
    for (i in 1:n) {
      p$V1[i] <- (p$V1[i]*-1) # Invert as high CRT is bad
    }
    
      for (i in 1:n) {
      # score cat
      if (p$V1[i] >= 1.0) {
        p$cat[i] <- "good"
      } else if (p$V1[i] <= -1.0) {
        p$cat[i] <- "bad"
      } else  {
        p$cat[i] <- "average"
      }
        
      # meta cat
      if (p$z.pm[i] >= 0.5) {
        p$mCat[i] <- "highConf"
      } else if (p$z.pm[i] <= -0.5) {
        p$mCat[i] <- "lowConf"
      }  else {
        p$mCat[i] <- "uncertain"
      }
        
      # # meta cat
      #  if (p$pm[i] >= 60) {
      #   p$mCat[i] <- "highConf"
      # } else if (p$pm[i] <= 40) {
      #   p$mCat[i] <- "lowConf"
      # }  else {
      #   p$mCat[i] <- "uncertain"
      # }
        
        # if (p$pm[i] >= 75) {
      #   p$mCat[i] <- "highConf"
      # } else if (p$pm[i] <= 25) {
      #   p$mCat[i] <- "lowConf"
      # } else if (p$pm[i] >= 26 && p$pm[i] <= 49 ) {
      #   p$mCat[i] <- "lowMiddle"
      # } else if (p$pm[i] == 50 ) {
      #   p$mCat[i] <- "uncertain"
      # } else {
      #   p$mCat[i] <- "highMiddle"
      # }
      
      if (p$mCat[i] == "highConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_lowConf"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "good") {
        p$mCog[i] <- "good_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "good") {
        p$mCog[i] <- "good_lowConf"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_lowConf"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "average") {
        p$mCog[i] <- "average_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "good") {
        p$mCog[i] <- "good_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_uncertain"
      } else {
        p$mCog[i] <- "unclasified"
      }
    }

p1 <-  ggplot(data = p, aes(x = g , y = raw, colour = g)) +
          #geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          geom_jitter(size = pointSize) +
          geom_boxplot(alpha = 0.7, outlier.shape = NA) +
          stat_compare_means(label.x = 0.7, size = 6) +
          ggtitle("A) Motor control performance") +
          xlab("Group") +
          ylab("Motor control (ms)") +
          labs(colour = "Group") +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  


          # scale_x_discrete(labels=c("average_highConf" = "High confidence", "average_lowConf" = "Low confidence", "average_uncertain" = "uncertain"))
 
ggdraw(p1)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/motorControl.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

 
p2 <-  ggplot(data = p, aes(x = g, y = pm, colour = g)) +
        #geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_jitter(size = pointSize) +
        geom_boxplot(alpha = 0.7, outlier.shape = NA) +
        stat_compare_means(label.x = 0.7, size = 6) +
        ggtitle("B) Motor control confidence judgement") +
        xlab("Group") +
        ylab("Confidence in performance") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)  
ggdraw(p2)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/motorControl_meta.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)

#p$pm[p$pm == 50] <- NA
p3 <-  ggplot(data = p, aes(pm , y = raw, colour = g)) +
          geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          geom_smooth(method = lm, size = 1) +
          stat_cor(method = "spearman", size = 6) + #size = 12
          ggtitle("C) Motor control & metacognitive judgement") +
          xlab("Confidence judgement") +
          ylab("Motor control (ms)") +
          labs(colour = "Group") +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  

ggdraw(p3)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/motorControl-meta.pdf", plot = p3, width = 12, height = 8, units = c("in"), dpi = 300)

    
# Plot of CRT & confidence judgment
p4 <-  ggplot(data = p, aes(x = g , y = raw, colour = mCat)) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(alpha = 0.7) +
        geom_hline(yintercept = median(p$raw), linetype = 2) + # Add horizontal line at base
        ggtitle("D) Motor control & confidence in performance") +
        xlab("Group") +
        ylab("Motor control (ms)") +
        labs(colour = "Reflection") +
        colPalette +
        theme(text = facetText, legend.text = facetText)  

ggdraw(p4)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/motorControl_metacog-group.pdf", plot = p4, width = 12, height = 8, units = c("in"), dpi = 300)

fPlot <- ggarrange(
         p1, 
         p2, 
         p3,
         p4,
         nrow = 2, ncol = 2)
fPlot
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/motorControlSummary.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)


### 

p5 <-  ggplot(data = p, aes(x = mCat, y = raw, colour = g)) +
        geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        #geom_jitter(shape=1) +
        geom_boxplot(alpha = 0.7) +
        ggtitle("Motor control & confidence in performance") +
        xlab("Confidence in performance") +
        ylab("Motor control (ms)") +
        labs(colour = "Group") +
        #colPalette
        scale_colour_manual(values=npgGroupPalette)
ggdraw(p5)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/motorControl_mCat.pdf", plot = p5, width = 12, height = 8, units = c("in"), dpi = 300)


p6 <-  ggplot(data = p, aes(x = mCog , y = V1, colour = g)) +
          geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          geom_jitter() +
          geom_boxplot(alpha = 0.7) +
          ggtitle("Motor control performance judgment") +
          xlab("metacognition") +
          ylab("z-score") +
          labs(colour = "Group") +
          theme(text = textOption, axis.text.x=element_text(angle=45, vjust=1, hjust=1.0)) +
          #colPalette
          scale_colour_manual(values=npgGroupPalette)
          # scale_x_discrete(labels=c("average_highConf" = "High confidence", "average_lowConf" = "Low confidence", "average_uncertain" = "uncertain"))
 
ggdraw(p6)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/motorControl-mCat-z.pdf", plot = p6, width = 12, height = 8, units = c("in"), dpi = 300)



# # Do some stats
m1 <- lm(raw ~ mCat*g, data = p) # *mCog*
Anova(m1, type="II")
# #summary(m1)
lsm = lsmeans(m1, ~g|mCat) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

#require("dplyr")
df <- p
group_by(df, g, mCat) %>%
  summarise(
    count = n(),
    mean = mean(raw, na.rm = TRUE),
    sd = sd(raw, na.rm = TRUE)
  )


# Linear model predicic confidence by performance and group
m2 <- lm(pm ~ raw*g, data = p)
# get results of model
summary(m2) 
# test if slopes are different to 0 for each group (does CI cross 0)
emtrends(m2, ~ g, var = "raw") 
# compare if slopes are different between groups (interaction)
lsm = lsmeans(m2, ~g) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

Anova(m2, type="II")

# # linear model
# m2 <- lm(pm ~ raw*g, data = p) # *mCog*
# Anova(m2, type="II")
# # #summary(m1)
# lsm = lsmeans(m2, ~g) # mCog*
# contrast(lsm, interaction = "pairwise", adjust="tukey")
```

# SRT
```{r}

ps <- scale(as.numeric(as.character(srt.tp1.df$srt)))
rm(p)
p <- as.data.frame(ps)
p$pm <- srt.tp1.df$srt.conf
p$z.pm <- scale(p$pm)
p$raw <- as.numeric(as.character(srt.tp1.df$srt))
p$z.pm <- scale(p$pm)
p$g <- srt.tp1.df$Group
p <- na.omit(p)

    n = length(p$V1)
    for (i in 1:n) {
      p$V1[i] <- (p$V1[i]*-1) # Invert as high CRT is bad
    }
    
      for (i in 1:n) {
      # score cat
      if (p$V1[i] >= 1.0) {
        p$cat[i] <- "good"
      } else if (p$V1[i] <= -1.0) {
        p$cat[i] <- "bad"
      } else  {
        p$cat[i] <- "average"
      }
        
        
      # meta cat
      if (p$z.pm[i] >= 0.5) {
        p$mCat[i] <- "highConf"
      } else if (p$z.pm[i] <= -0.5) {
        p$mCat[i] <- "lowConf"
      }  else {
        p$mCat[i] <- "uncertain"
      }
        
        
      # # meta cat
      #  if (p$pm[i] >= 60) {
      #   p$mCat[i] <- "highConf"
      # } else if (p$pm[i] <= 40) {
      #   p$mCat[i] <- "lowConf"
      # }  else {
      #   p$mCat[i] <- "uncertain"
      # }
        
        # if (p$pm[i] >= 75) {
      #   p$mCat[i] <- "highConf"
      # } else if (p$pm[i] <= 25) {
      #   p$mCat[i] <- "lowConf"
      # } else if (p$pm[i] >= 26 && p$pm[i] <= 49 ) {
      #   p$mCat[i] <- "lowMiddle"
      # } else if (p$pm[i] == 50 ) {
      #   p$mCat[i] <- "uncertain"
      # } else {
      #   p$mCat[i] <- "highMiddle"
      # }
      
      if (p$mCat[i] == "highConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_lowConf"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "good") {
        p$mCog[i] <- "good_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "good") {
        p$mCog[i] <- "good_lowConf"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_lowConf"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "average") {
        p$mCog[i] <- "average_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "good") {
        p$mCog[i] <- "good_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_uncertain"
      } else {
        p$mCog[i] <- "unclasified"
      }
    }

p1 <-  ggplot(data = p, aes(x = g , y = raw, colour = g)) +
          #geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          geom_jitter(size = pointSize) +
          geom_boxplot(alpha = 0.7, outlier.shape = NA) +
          stat_compare_means(label.x = 0.7, size = 6) +
          ggtitle("A) SRT performance") +
          xlab("Group") +
          ylab("Simple Reaction time (ms)") +
          labs(colour = "Group") +
          #theme(text = textOption, axis.text.x=element_text(angle=45, vjust=1, hjust=1.0)) +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  

ggdraw(p1)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/srt.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

 
p2 <-  ggplot(data = p, aes(x = g, y = pm, colour = g)) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(alpha = 0.7, outlier.shape = NA) +
        stat_compare_means(label.x = 0.7, size = 6) +
        ggtitle("B) SRT performance judgement") +
        xlab("Group") +
        ylab("Confidence in performance") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)  



ggdraw(p2)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/srt_meta.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)

#p$pm[p$pm == 50] <- NA
p3 <-  ggplot(data = p, aes(pm , y = raw, colour = g)) +
          geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          geom_smooth(method = lm) +
          stat_cor(method = "spearman", size = 6) + #size = 12
          ggtitle("C) SRT & metacognitive judgement") +
          xlab("Performance judgement") +
          ylab("Simple reaction time (ms)") +
          labs(colour = "Group") +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  

ggdraw(p3)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/srt-meta.pdf", plot = p3, width = 12, height = 8, units = c("in"), dpi = 300)

# Plot of CRT & confidence judgment
p4 <-  ggplot(data = p, aes(x = g , y = raw, colour = mCat)) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(alpha = 0.7, outlier.shape = NA) +
        geom_hline(yintercept = median(p$raw), linetype = 2) + # Add horizontal line at base
        ggtitle("D) SRT & confidence in performance") +
        xlab("Group") +
        ylab("Simple Reaction time (ms)") +
        labs(colour = "Reflection") +
        colPalette +
        theme(text = facetText, legend.text = facetText)  

ggdraw(p4)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/srt_metacog-group.pdf", plot = p4, width = 12, height = 8, units = c("in"), dpi = 300)

fPlot <- ggarrange(
         p1, 
         p2, 
         p3,
         p4,
         nrow = 2, ncol = 2)
fPlot
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/srtSummary.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)


### 

p5 <-  ggplot(data = p, aes(x = mCat, y = raw, colour = g)) +
        geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        #geom_jitter(shape=1) +
        geom_boxplot(alpha = 0.7) +
        ggtitle("SRT & confidence in performance") +
        xlab("Confidence in performance") +
        ylab("Simple Reaction time (ms)") +
        labs(colour = "Group") +
        colPalette
        #scale_colour_manual(values=npgGroupPalette) + 
ggdraw(p5)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/srt_mCat.pdf", plot = p5, width = 12, height = 8, units = c("in"), dpi = 300)


p6 <-  ggplot(data = p, aes(x = mCog , y = V1, colour = g)) +
          geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          geom_jitter() +
          geom_boxplot(alpha = 0.7) +
          ggtitle("SRT performance judgment") +
          xlab("metacognition") +
          ylab("z-score") +
          labs(colour = "Group") +
          theme(text = textOption, axis.text.x=element_text(angle=45, vjust=1, hjust=1.0)) +
          colPalette
          # scale_x_discrete(labels=c("average_highConf" = "High confidence", "average_lowConf" = "Low confidence", "average_uncertain" = "uncertain"))
 
ggdraw(p6)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/srt-mCat-z.pdf", plot = p6, width = 12, height = 8, units = c("in"), dpi = 300)


# # Do some stats
m1 <- lm(raw ~ mCat*g, data = p) # *mCog*
Anova(m1, type="II")
# #summary(m1)
lsm = lsmeans(m1, ~g|mCat) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

df <- p
group_by(df, g, mCat) %>%
  summarise(
    count = n(),
    mean = mean(raw, na.rm = TRUE),
    sd = sd(raw, na.rm = TRUE)
  )

# Linear model predict confidence by performance and group
m2 <- lm(pm ~ raw*g, data = p)
# get results of model
summary(m2) 
# test if slopes are different to 0 for each group (does CI cross 0)
emtrends(m2, ~ g, var = "raw") 
# compare if slopes are different between groups (interaction)
lsm = lsmeans(m2, ~g) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

Anova(m2, type="II")



ggplot(data = conf.df, aes(x = pomp$pomp.mc, y = mc, color = metaAcc.p$group)) + geom_point() + geom_smooth(method = "lm") + stat_cor()

###

# # setup model
# fit1 = lm(raw ~ g + mCat + g:mCat, data = p)
# fit2 = lm(log(raw) ~ g + mCat + g:mCat, data = p)
# Anova(fit1, type = "II")
# 
# # From lsmeans
# marginal = lsmeans(fit1, pairwise ~ g:mCat, adjust="tukey") ###Tukey-adjusted comparisons
# marginal$contrasts
# 
# # emmeans - not sure why log transforming
# # https://aosmith.rbind.io/2019/03/25/getting-started-with-emmeans/
# marginal = emmeans(fit2, pairwise ~ g:mCat, adjust="tukey")
# marginal$emmeans
# marginal$contrasts
# emmeans(fit2, specs = pairwise ~ g:mCat, type = "response")

```





# CRT
```{r}

ps <- scale(as.numeric(as.character(crt.tp1.df$crt)))
rm(p)
p <- as.data.frame(ps)
p$pm <- crt.tp1.df$crt.conf
p$z.pm <- scale(crt.tp1.df$crt.conf)
p$raw <- as.numeric(as.character(crt.tp1.df$crt))
p$g <- crt.tp1.df$Group
p <- na.omit(p)

    n = length(p$V1)
    for (i in 1:n) {
      p$V1[i] <- (p$V1[i]*-1) # Invert as high CRT is bad
    }
    
      for (i in 1:n) {
      # score cat
      if (p$V1[i] >= 1.0) {
        p$cat[i] <- "good"
      } else if (p$V1[i] <= -1.0) {
        p$cat[i] <- "bad"
      } else  {
        p$cat[i] <- "average"
      }
        
      # meta cat
      if (p$z.pm[i] >= 0.5) {
        p$mCat[i] <- "highConf"
      } else if (p$z.pm[i] <= -0.5) {
        p$mCat[i] <- "lowConf"
      }  else {
        p$mCat[i] <- "uncertain"
      }
        
      if (p$mCat[i] == "high" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_highConf"
      } else if (p$mCat[i] == "low" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_lowConf"
      } else if (p$mCat[i] == "high" && p$cat[i] == "good") {
        p$mCog[i] <- "good_highConf"
      } else if (p$mCat[i] == "low" && p$cat[i] == "good") {
        p$mCog[i] <- "good_lowConf"
      } else if (p$mCat[i] == "high" && p$cat[i] == "average") {
        p$mCog[i] <- "average_highConf"
      } else if (p$mCat[i] == "low" && p$cat[i] == "average") {
        p$mCog[i] <- "average_lowConf"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "average") {
        p$mCog[i] <- "average_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "good") {
        p$mCog[i] <- "good_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_uncertain"
      } else {
        p$mCog[i] <- "unclasified"
      }
    }
        

 # scale_x_discrete(labels=c("average_highConf" = "High confidence", "average_lowConf" = "Low confidence", "average_uncertain" = "uncertain"))

p1 <-  ggplot(data = p, aes(x = g , y = raw, colour = g)) +
          geom_point(size = fpSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          #geom_jitter() +
          geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
          stat_compare_means(label.x = 0.7, size = 6) +
          ggtitle("A) CRT performance") +
          xlab("Group") +
          ylab("Choice Reaction time (ms)") +
          labs(colour = "Group") +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  

 
ggdraw(p1)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/crt.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

 
p2 <-  ggplot(data = p, aes(x = g, y = pm, colour = g)) +
        geom_point(size = fpSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
        stat_compare_means(label.x = 0.7, size = 6) +
        ggtitle("B) CRT performance judgement") +
        xlab("Group") +
        ylab("Confidence in performance") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)  


ggdraw(p2)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/crt_meta.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)

#p$pm[p$pm == 50] <- NA
p3 <-  ggplot(data = p, aes(pm , y = raw, colour = g)) +
          geom_point(size = fpSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          geom_smooth(method = lm) +
          stat_cor(method = "spearman", size = 6) + #size = 12
          ggtitle("C) CRT & metacognitive judgement") +
          xlab("Performance judgement") +
          ylab("Choice reaction time (ms)") +
          labs(colour = "Group") +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  


ggdraw(p3)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/crt-meta.pdf", plot = p3, width = 12, height = 8, units = c("in"), dpi = 300)


    
# Plot of CRT & confidence judgment
p4 <-  ggplot(data = p, aes(x = g , y = raw, colour = mCat)) +
        geom_point(size = fpSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
        geom_hline(yintercept = median(p$raw), linetype = 2) + # Add horizontal line at base
        ggtitle("D) CRT & confidence in performance") +
        xlab("Group") +
        ylab("Choice Reaction time (ms)") +
        labs(colour = "judgement") +
        colPalette +
        theme(text = facetText, legend.text = facetText)

ggdraw(p4)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/crt_metacog-group.pdf", plot = p4, width = 12, height = 8, units = c("in"), dpi = 300)


fPlot <- ggarrange(
         p1, 
         p2, 
         p3,
         p4,
         nrow = 2, ncol = 2)

fPlot
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/crtSummary.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)


### 

p5 <-  ggplot(data = p, aes(x = mCat, y = raw, colour = g)) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(size = 1, alpha = 0.7) +
        ggtitle("CRT & confidence in performance") +
        xlab("Confidence in performance") +
        ylab("Choice Reaction time (ms)") +
        labs(colour = "Group") +
        colPalette +
        theme(text = facetText, legend.text = facetText)
ggdraw(p5)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/crt_mCat.pdf", plot = p5, width = 12, height = 8, units = c("in"), dpi = 300)


p6 <-  ggplot(data = p, aes(x = mCog , y = V1, colour = g)) +
          geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          geom_boxplot(size = 1, alpha = 0.7) +
          ggtitle("CRT performance judgment") +
          xlab("metacognition") +
          ylab("z-score") +
          labs(colour = "Group") +
          theme(text = textOption, axis.text.x=element_text(angle=45, vjust=1, hjust=1.0)) +
          colPalette +
          theme(text = facetText, legend.text = facetText)
          # scale_x_discrete(labels=c("average_highConf" = "High confidence", "average_lowConf" = "Low confidence", "average_uncertain" = "uncertain"))
 
ggdraw(p6)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/crt-mCat-z.pdf", plot = p6, width = 12, height = 8, units = c("in"), dpi = 300)


# # Do some stats
m1 <- lm(raw ~ mCat*g, data = p) # *mCog*
Anova(m1, type="II")
# #summary(m1)
lsm = lsmeans(m1, ~g|mCat) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

# df <- p
# group_by(df, g, mCat) %>%
#   summarise(
#     count = n(),
#     mean = mean(raw, na.rm = TRUE),
#     sd = sd(raw, na.rm = TRUE)
#   )

# Linear model predict confidence by performance and group
m2 <- lm(pm ~ raw*g, data = p)
# get results of model
summary(m2) 
# test if slopes are different to 0 for each group (does CI cross 0)
emtrends(m2, ~ g, var = "raw") 
# compare if slopes are different between groups (interaction)
lsm = lsmeans(m2, ~g) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

Anova(m2, type="II")

###

# # setup model
# fit1 = lm(raw ~ g + mCat + g:mCat, data = p)
# fit2 = lm(log(raw) ~ g + mCat + g:mCat, data = p)
# Anova(fit1, type = "II")
# 
# # From lsmeans
# marginal = lsmeans(fit1, pairwise ~ g:mCat, adjust="tukey") ###Tukey-adjusted comparisons
# marginal$contrasts
# 
# # emmeans - not sure why log transforming
# # https://aosmith.rbind.io/2019/03/25/getting-started-with-emmeans/
# marginal = emmeans(fit2, pairwise ~ g:mCat, adjust="tukey")
# marginal$emmeans
# marginal$contrasts
# emmeans(fit2, specs = pairwise ~ g:mCat, type = "response")

```


# Target Detection
```{r}

ps <- scale(as.numeric(as.character(targetDetection.tp1.df$targetDetection)))
rm(p)
p <- as.data.frame(ps)
p$pm <- targetDetection.tp1.df$targetDetection.conf
p$z.pm <- scale(p$pm)
p$raw <- as.numeric(as.character(targetDetection.tp1.df$targetDetection))
p$g <- targetDetection.tp1.df$Group
p <- na.omit(p)

    n = length(p$V1)
      for (i in 1:n) {
      # score cat
      if (p$V1[i] >= 1.0) {
        p$cat[i] <- "good"
      } else if (p$V1[i] <= -1.0) {
        p$cat[i] <- "bad"
      } else  {
        p$cat[i] <- "average"
      }
        
              # meta cat
      if (p$z.pm[i] >= 0.5) {
        p$mCat[i] <- "highConf"
      } else if (p$z.pm[i] <= -0.5) {
        p$mCat[i] <- "lowConf"
      }  else {
        p$mCat[i] <- "uncertain"
      }
        
      # # meta cat
      #  if (p$pm[i] >= 60) {
      #   p$mCat[i] <- "highConf"
      # } else if (p$pm[i] <= 40) {
      #   p$mCat[i] <- "lowConf"
      # }  else {
      #   p$mCat[i] <- "uncertain"
      # }
  
      if (p$mCat[i] == "highConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_lowConf"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "good") {
        p$mCog[i] <- "good_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "good") {
        p$mCog[i] <- "good_lowConf"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_lowConf"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "average") {
        p$mCog[i] <- "average_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "good") {
        p$mCog[i] <- "good_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_uncertain"
      } else {
        p$mCog[i] <- "unclasified"
      }
    }

p1 <-  ggplot(data = p, aes(x = g , y = raw, colour = g)) +
          geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          #geom_jitter() +
          geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
          stat_compare_means(label.x = 0.7, size = 6) +
          ggtitle("A) Target Detection performance") +
          xlab("Group") +
          ylab("Target Detection") +
          labs(colour = "Group") +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  


ggdraw(p1)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/TargetDetection.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

 
p2 <-  ggplot(data = p, aes(x = g, y = pm, colour = g)) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        #geom_jitter() +
        geom_boxplot(alpha = 0.7, outlier.shape = NA) +
        stat_compare_means(label.x = 0.7, size = 6) +
        ggtitle("B) Target Detection performance judgement") +
        xlab("Group") +
        ylab("Confidence in performance") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)  


ggdraw(p2)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/TargetDetection_meta.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)

#p$pm[p$pm == 50] <- NA
p3 <-  ggplot(data = p, aes(pm , y = raw, colour = g)) +
          geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          #geom_jitter() +
          geom_smooth(method = lm) +
          stat_cor(method = "spearman", size = 6) + #size = 12
          ggtitle("C) Target Detection & metacognitive judgement") +
          xlab("Performance judgement") +
          ylab("Target Detection") +
          labs(colour = "Group") +
          #theme(text = textOption, axis.text.x=element_text(angle=45, vjust=1, hjust=1.0)) +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  


ggdraw(p3)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/TargetDetection-meta.pdf", plot = p3, width = 12, height = 8, units = c("in"), dpi = 300)


# Plot of CRT & confidence judgment
p4 <-  ggplot(data = p, aes(x = g , y = raw, colour = mCat)) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
        geom_hline(yintercept = median(p$raw), linetype = 2) + # Add horizontal line at base
        ggtitle("D) Target Detection & confidence in performance") +
        xlab("Group") +
        ylab("Target Detection") +
        labs(colour = "Reflection") +
        colPalette +
        theme(text = facetText, legend.text = facetText)

ggdraw(p4)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/TargetDetection_metacog-group.pdf", plot = p4, width = 12, height = 8, units = c("in"), dpi = 300)


fPlot <- ggarrange(
         p1, 
         p2, 
         p3,
         p4,
         nrow = 2, ncol = 2)
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/Target_DetectionSummary.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)


###

p5 <-  ggplot(data = p, aes(x = mCat, y = raw, colour = g)) +
        geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(alpha = 0.7) +
        ggtitle("Target Detection & confidence in performance") +
        xlab("Confidence in performance") +
        ylab("Target Detection") +
        labs(colour = "Group") +
        colPalette
ggdraw(p5)
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/TargetDetection_mCat.pdf", plot = p5, width = 12, height = 8, units = c("in"), dpi = 300)


p6 <-  ggplot(data = p, aes(x = mCog , y = V1, colour = g)) +
          geom_point(position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          geom_jitter() +
          geom_boxplot(alpha = 0.7) +
          ggtitle("Target Detection performance judgment") +
          xlab("metacognition") +
          ylab("z-score") +
          labs(colour = "Group") +
          theme(text = textOption, axis.text.x=element_text(angle=45, vjust=1, hjust=1.0)) +
          colPalette

ggdraw(p6)
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/TargetDetection-mCat-z.pdf", plot = p6, width = 12, height = 8, units = c("in"), dpi = 300)

# # Do some stats
m1 <- lm(raw ~ mCat*g, data = p) # *mCog*
Anova(m1, type="II")
# #summary(m1)
lsm = lsmeans(m1, ~g|mCat) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

# df <- p
# group_by(df, g, mCat) %>%
#   summarise(
#     count = n(),
#     mean = mean(raw, na.rm = TRUE),
#     sd = sd(raw, na.rm = TRUE)
#   )


# Linear model predicic confidence by performance and group
m2 <- lm(pm ~ raw*g, data = p)
# get results of model
summary(m2) 
# test if slopes are different to 0 for each group (does CI cross 0)
emtrends(m2, ~ g, var = "raw") 
# compare if slopes are different between groups (interaction)
lsm = lsmeans(m2, ~g) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")


Anova(m2, type="II")


###

# # setup model
# fit1 = lm(raw ~ g + mCat + g:mCat, data = p)
# fit2 = lm(log(raw) ~ g + mCat + g:mCat, data = p)
# Anova(fit1, type = "II")
# 
# # From lsmeans
# marginal = lsmeans(fit1, pairwise ~ g:mCat, adjust="tukey") ###Tukey-adjusted comparisons
# marginal$contrasts
# 
# # emmeans - not sure why log transforming
# # https://aosmith.rbind.io/2019/03/25/getting-started-with-emmeans/
# marginal = emmeans(fit2, pairwise ~ g:mCat, adjust="tukey")
# marginal$emmeans
# marginal$contrasts
# emmeans(fit2, specs = pairwise ~ g:mCat, type = "response")


```

# Trails
```{r}

ps <- scale(as.numeric(as.character(trails.tp1.df$trailCost)))
rm(p)
p <- as.data.frame(ps)
p$pm <- trails.tp1.df$trail.conf
p$pm <- trails.tp1.df$trail.conf
p$z.pm <- scale(p$pm)
p$raw <- as.numeric(as.character(trails.tp1.df$trailCost))
p$g <- trails.tp1.df$Group
p <- na.omit(p)

    n = length(p$V1)
        for (i in 1:n) {
        p$V1[i] <- (p$V1[i]*-1) # Invert as high CRT is bad
      }
      for (i in 1:n) {
      # score cat
      if (p$V1[i] >= 1) {
        p$cat[i] <- "good"
      } else if (p$V1[i] <= -1) {
        p$cat[i] <- "bad"
      } else  {
        p$cat[i] <- "average"
      }
        
       # meta cat
      if (p$z.pm[i] >= 0.5) {
        p$mCat[i] <- "highConf"
      } else if (p$z.pm[i] <= -0.5) {
        p$mCat[i] <- "lowConf"
      }  else {
        p$mCat[i] <- "uncertain"
      }
      
        
      # # meta cat
      #  if (p$pm[i] >= 60) {
      #   p$mCat[i] <- "highConf"
      # } else if (p$pm[i] <= 40) {
      #   p$mCat[i] <- "lowConf"
      # }  else {
      #   p$mCat[i] <- "uncertain"
      # }
  
      if (p$mCat[i] == "highConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_lowConf"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "good") {
        p$mCog[i] <- "good_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "good") {
        p$mCog[i] <- "good_lowConf"
      } else if (p$mCat[i] == "highConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_highConf"
      } else if (p$mCat[i] == "lowConf" && p$cat[i] == "average") {
        p$mCog[i] <- "average_lowConf"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "average") {
        p$mCog[i] <- "average_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "good") {
        p$mCog[i] <- "good_uncertain"
      } else if (p$mCat[i] == "uncertain" && p$cat[i] == "bad") {
        p$mCog[i] <- "bad_uncertain"
      } else {
        p$mCog[i] <- "unclasified"
      }
    }

p1 <-  ggplot(data = p, aes(x = g , y = raw, colour = g)) +
          geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          #geom_jitter() +
          geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
          stat_compare_means(label.x = 0.7, size = 6) +
          ggtitle("A) Trails (switch cost performance)") +
          xlab("Group") +
          ylab("Switch cost (ms)") +
          labs(colour = "Group") +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  

ggdraw(p1)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/Trails.pdf", plot = p1, width = 12, height = 8, units = c("in"), dpi = 300)

p2 <-  ggplot(data = p, aes(x = g, y = pm, colour = g)) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        #geom_jitter() +
        geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
        stat_compare_means(label.x = 0.7, size = 6) +
        ggtitle("B) Trails performance judgement") +
        xlab("Group") +
        ylab("Confidence in performance") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)  

ggdraw(p2)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/Trails_meta.pdf", plot = p2, width = 12, height = 8, units = c("in"), dpi = 300)

#p$pm[p$pm == 50] <- NA
p3 <-  ggplot(data = p, aes(pm , y = raw, colour = g)) +
          geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          #geom_jitter() +
          geom_smooth(method = lm) +
          stat_cor(method = "spearman", size = 6) + #size = 12
          ggtitle("C) Trails & metacognitive judgement") +
          xlab("Performance judgement") +
          ylab("Switch cost (ms)") +
          labs(colour = "Group") +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  

ggdraw(p3)   
# ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/Trails-meta.pdf", plot = p3, width = 12, height = 8, units = c("in"), dpi = 300)


# Plot of CRT & confidence judgment
p4 <-  ggplot(data = p, aes(x = g , y = raw, colour = mCat)) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
        geom_hline(yintercept = median(p$raw), linetype = 2) + # Add horizontal line at base
        ggtitle("D) Trails & confidence in performance") +
        xlab("Group") +
        ylab("Switch cost (ms)") +
        labs(colour = "judgement") +
        colPalette +
        theme(text = facetText, legend.text = facetText)

ggdraw(p4)   
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/Trails_metacog-group.pdf", plot = p4, width = 12, height = 8, units = c("in"), dpi = 300)


fPlot <- ggarrange(
         p1, 
         p2, 
         p3,
         p4,
         nrow = 2, ncol = 2)
fPlot
ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch7 Metacognition/rPlots/TrailsSummary.pdf", plot = fPlot, width = 12, height = 8, units = c("in"), dpi = 300)


###

p5 <-  ggplot(data = p, aes(x = mCat, y = raw, colour = g)) +
        geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
        geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
        ggtitle("Trails & confidence in performance") +
        xlab("Confidence in performance") +
        ylab("Switch cost (ms)") +
        labs(colour = "Group") +
        scale_color_manual(values = npgGroupPalette) +
        theme(text = facetText, legend.text = facetText)  

ggdraw(p5)
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/Trails_mCat.pdf", plot = p5, width = 12, height = 8, units = c("in"), dpi = 300)


p6 <-  ggplot(data = p, aes(x = mCog , y = V1, colour = g)) +
          geom_point(size = pointSize, position = position_jitterdodge(jitter.width = NULL, jitter.height = 0.25, dodge.width = 0.75, seed = NA)) +
          # geom_jitter() + 
          geom_boxplot(size = 1, alpha = 0.7, outlier.shape = NA) +
          ggtitle("Trails performance judgment") +
          xlab("metacognition") +
          ylab("z-score") +
          labs(colour = "Group") +
          theme(text = textOption, axis.text.x=element_text(angle=45, vjust=1, hjust=1.0)) +
          scale_color_manual(values = npgGroupPalette) +
          theme(text = facetText, legend.text = facetText)  

table(p$mCog, p$g)

ggdraw(p6)
#ggsave("~/Google Drive/Imperial/PhD/Thesis/Ch6 Metacognition/rPlots/Trails-mCat-z.pdf", plot = p6, width = 12, height = 8, units = c("in"), dpi = 300)


# # Do some stats
m1 <- lm(raw ~ mCat*g, data = p) # *mCog*
Anova(m1, type="II")
# #summary(m1)
lsm = lsmeans(m1, ~g|mCat) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

# df <- p
# group_by(df, g, mCat) %>%
#   summarise(
#     count = n(),
#     mean = mean(raw, na.rm = TRUE),
#     sd = sd(raw, na.rm = TRUE)
#   )


# # Do some stats
m2 <- lm(pm ~ raw*g, data = p) # *mCog*
Anova(m2, type="II")

# #summary(m1)
lsm = lsmeans(m2, ~g) # mCog*
contrast(lsm, interaction = "pairwise", adjust="tukey")

reg.todo <- lm(pm ~ g/raw - 1, data= p)
summary(reg.todo)

```
